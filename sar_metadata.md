Understood. I will compile a technical, developer-level breakdown of Sentinel-1 Level-0 RAW products, focusing on:

1. The binary structure of the `.dat` files, including header field structures, bit allocations, and application details.
2. The purpose and structure defined in the `.xsd` schema files for metadata and annotation.
3. Specifications that are broadly applicable across all Sentinel-1 Level-0 RAW data.

I'll begin the research and let you know once the detailed information is ready.


# Sentinel‑1 Level‑0 RAW Product Structure and Schema Analysis

## Overview of Sentinel‑1 Level‑0 RAW Products

Sentinel‑1 Level‑0 (RAW) products contain the **unprocessed SAR instrument source data** as downlinked from the satellite. They are packaged in the Sentinel SAFE format, which includes:

* **One or two Measurement Data Component (MDC) files** with extension `.dat`, containing the stream of raw SAR instrument source packets in binary form (two files are present for dual-polarization acquisitions – one per polarization channel).
* **Annotation Data Component (ADC) file(s)** (binary) which provide one record per each instrument source packet, containing ancillary annotations (timing, channel info, etc.) but no signal samples. There is one annotation file corresponding to each measurement data file.
* **Index Data Component (IDC) file(s)** (binary) which index the measurement data for quick access – describing logical data segments (byte locations, times, sizes, etc.) within the measurement file. One index file is provided per measurement data file.
* **A manifest (XML)** describing product metadata (satellite, mode, timestamps, orbit) and referencing all files.
* **Representation Data Component schemas** (XSD files in a `support/` folder) that formally describe the binary format of the Measurement, Annotation, and Index components. These include `s1-level-0.xsd` (measurement schema), `s1-level-0-annot.xsd` (annotation schema), and `s1-level-0-index.xsd` (index schema).

Each Level‑0 product corresponds to a **time-ordered “slice” of a SAR data take** (typically \~25 seconds for Stripmap/IW, with small overlaps) rather than an entire acquisition. The product timeline usually begins with a short **preamble** containing noise and calibration pulses, followed by the main imaging pulses (and periodic calibration pulses interleaved, as described later).

## 1. Binary Structure of the `.dat` Measurement Files

The core of a Level‑0 RAW product is the measurement `.dat` file, which contains a sequence of **Instrument Source Packets (ISPs)** – the fundamental data units downlinked from the Sentinel‑1 SAR. Each ISP (also referred to as a “record” or “packet”) comprises a fixed-length **header** followed by a block of compressed radar echo samples (the **user data**). The packets are stored back-to-back in chronological order of acquisition. In dual-pol mode, separate files contain the packets from each polarization channel.

### 1.1 Packet Primary Header (CCSDS Packet Header)

Every ISP begins with a 6-byte primary header following the CCSDS Space Packet standard. This header contains general identification and sizing fields:

* **Packet Version Number** (3 bits) – format version (typically `0` for CCSDS).
* **Packet Type** (1 bit) – distinguishes telemetry vs. telecommand packets (SAR science data are telemetry type).
* **Secondary Header Flag** (1 bit) – set to `1` to indicate that a secondary header is present (which it is for SAR packets).
* **APID (Application Process ID)** – an 11-bit identifier for the data stream. In Sentinel‑1 this is split into a 7-bit **Process ID** (PID) and 4-bit **Packet Category** (PCAT). Different APIDs may be used to distinguish SAR instrument channels or modes. For example, dual-pol data channels are assigned distinct APIDs/PIDs to separate the two polarization streams at the receiver.
* **Sequence Flags** (2 bits) – frame sequencing status per CCSDS (e.g. `11` for standalone packets, `01` for start of sequence, `00` continuation, `10` end of sequence).
* **Packet Sequence Count** (14 bits) – a sequential counter of packets (modulo 2^14) within the product slice. This can be used to detect missing packets in a slice.
* **Packet Data Length** (16 bits) – size of the remaining packet content *minus one*. This field (stored as an unsigned short) gives the length in bytes of the combined secondary header + user data minus 1. In practice, the primary header is 6 bytes and the secondary header is fixed at 62 bytes, so this length field allows calculating the user data length for each packet.

> **Note:** The APID values encode the type of data stream. For Sentinel‑1 SAR, specific APIDs correspond to SAR telemetry from a given instrument mode and polarization. For dual-pol acquisitions, two APIDs are used (one per polarization channel), and the ground segment writes two separate `.dat` files accordingly.

### 1.2 Packet Secondary Header (SAR Instrument Header)

Following the primary header, each ISP includes a 62-byte **secondary header** containing fields specific to the SAR instrument and the acquisition. These fields convey timing, configuration, and status information critical for processing the radar data. The secondary header can be conceptually grouped into several sections (often called “services” in the ESA documentation):

* **Datation (Time) Service:**

  * **Coarse Time** (4 bytes, uint) – The timestamp (most significant portion) marking the acquisition time of this pulse, in GPS-based time or mission elapsed time. Typically this is in seconds (or another base unit) relative to a reference epoch.
  * **Fine Time** (2 bytes, uint) – Fractional part of the time to refine the timestamp (e.g. in sub-millisecond or microsecond units). Together, coarse and fine time pinpoint the transmit time of the radar pulse or start time of sampling with microsecond precision.

* **Fixed Ancillary Data:**

  * **Sync Marker** (4 bytes, hex array) – A fixed pattern (`0xAAAAAAAA` commonly) used for synchronization validation. This helps identify the start of the packet in the bit stream.
  * **Data Take ID** (4 bytes, uint) – An identifier for the continuous data-take or acquisition segment. This ID ties the packet to a specific acquisition session (unique per orbit cycle) and is also reflected in the product filename.
  * **ECC Number** (1 byte, uchar) – An **Experiment Configuration Counter** or mode ID for the instrument’s internal timeline. This may index the radar timeline “experiment” (pattern of pulses) being executed.
  * **Test Mode Flag** (3 bits) – Indicates if the instrument was in a special test mode for this pulse (e.g., an internal diagnostic mode). Typically `0` for nominal imaging.
  * **RX Channel ID** (4 bits) – Identifies which receive channel or polarization was used for this pulse. For single-pol modes this is constant, but for dual-pol, this distinguishes pulses recorded on the two parallel receiver channels (e.g. Channel 0 = HH, Channel 1 = HV for an HH+HV dual-pol mode).
  * **Instrument Configuration ID** (4 bytes, uint) – A code that maps to the active radar instrument configuration for this pulse. This ID links to the radar parameters in the mission’s configuration database (PRF, pulse width, modulation, etc.). In a standard data-take, this may remain constant, but it could change if the instrument reconfigures (e.g., switching sub-swath beams or changing modulation).

* **Sub-Commutated Ancillary Data:**

  * **Data Word Index** (1 byte, uchar) – An index indicating which ancillary telemetry parameter is included in this packet’s data word field. The instrument cycles through various ancillary parameters over successive pulses (sub-commutation).
  * **Data Word** (2 bytes, ushort) – The value of an ancillary parameter (indexed by the above). For example, the SAR might periodically embed readings like internal temperatures, power levels, etc., one at a time in this field.

* **Counters Service:**

  * **Space Packet Count** (4 bytes, uint) – A continuous counter of SAR packets. This is often the global count of all SAR packets from the instrument (not resetting each slice). It provides an absolute sequence reference beyond the 14-bit sequence count in the primary header.
  * **PRI Count (Mode PRI Count)** (4 bytes, uint) – Essentially the **pulse count** within the current data-take or mode. This increments for each transmitted pulse (echo or calibration) and is used to identify the pulse number. It resets at the start of a new acquisition. The PRI count is vital for aligning pulses in processing (especially across product slices).

* **Radar Configuration/Support Data:**

  * **BAQ Mode** (5 bits) – Specifies the **Block Adaptive Quantization** mode used for onboard data compression. Sentinel‑1 uses BAQ to reduce the volume of raw echo data. This field encodes the quantization scheme (e.g. 3-bit, 4-bit quantization or a dynamic mode) and any Huffman coding variant in use. For example, values may correspond to `BAQ_3_BIT`, `BAQ_4_BIT`, `BAQ_5_BIT` or `FDBAQ_x` (Flexible Dynamic BAQ modes) as defined in the ESA documentation.
  * **BAQ Block Length** (1 byte, uchar) – The number of samples per block used for BAQ compression. This defines how the echo signal was partitioned into blocks for quantization.
  * **Range Decimation** (1 byte, uchar) – Indicates if any decimation (down-sampling) was applied in range (e.g., a presumming of ADC samples). Typically 0 for no decimation in standard modes.
  * **RX Gain** (1 byte, uchar) – The receiver gain setting (attenuation level) at the time of this pulse. Changes in RX gain (if any) would reflect here, though in standard operations this is usually fixed per mode.
  * **TX Ramp Rate** (2 bytes, ushort) – The frequency modulation rate of the chirp (if a linear FM chirp, this is related to chirp bandwidth). It may encode the slope of the frequency ramp of the transmitted pulse.
  * **TX Pulse Start Frequency** (2 bytes, ushort) – The starting frequency offset of the transmitted pulse’s chirp (relative to the radar’s center frequency). This, together with ramp rate and pulse length, defines the chirp spectrum.
  * **TX Pulse Length** (3 bytes, uint24) – The duration of the transmitted pulse (the chirp length) in some unit (e.g. microseconds or number of range samples). A 24-bit field allows precise specification of pulse length.
  * *(Spare bits are included as needed to align multi-bit fields to byte boundaries – e.g., a 3-bit spare (`secondSpare3Bit`) is present after TX Pulse Length to align subsequent fields).*

* **Radar Timing (Pulse Scheduling) Data:**

  * **PRI** (Pulse Repetition Interval) (3 bytes, uint24) – The time interval between this pulse and the next, in the instrument’s timing units. In a stable high-PRF burst, this would be constant; variations indicate timeline gaps or burst boundaries.
  * **SWST (Sampling Window Start Time)** (3 bytes, uint24) – The delay from pulse transmission to the start of sampling the echo. This effectively indicates the range gating – a larger SWST means the receiver was turned on later, skipping nearer ranges. Sentinel‑1 may adjust SWST for different sub-swaths (near vs far ranges) or to avoid early transmit interference.
  * **SWL (Sampling Window Length)** (3 bytes, uint24) – The length of the sampling window (i.e. the duration for which echo samples were acquired). This relates to the range swath extent captured: a longer SWL means capturing echoes from farther range. Together, SWST and SWL define the range interval “imaged” by that pulse.

* **SAS (Single/Antenna Sub-swath) and Calibration Status:**
  These fields indicate which beam/sub-swath the pulse belongs to and whether the pulse was a normal imaging echo or a calibration pulse:

  * **SSB Flag** (1 bit) – *SAR Source Beam* flag. When `0`, the pulse is a normal imaging echo and the following beam fields refer to the beam IDs; when `1`, the pulse is part of a calibration or special test, and certain fields are reinterpreted to describe calibration type.
  * **Polarisation** (3 bits) – The transmit/receive polarization of this pulse. This code distinguishes pulses like HH vs HV, etc. In single-pol modes it will be constant (e.g., `HH`), in dual-pol it may still be constant per channel (since each channel file carries one pol), but the field is defined to encode various pol combinations or schemes.
  * **Temperature Compensation** (2 bits) – Flag or code indicating if any real-time temperature compensation was applied to the signal (e.g., oscillator drift correction or power adjustment). Typically a setting from the radar’s calibration parameters.
  * **Elevation Beam Address / SASTest+CalType** (4 bits) – If SSBFlag=0 (normal pulse), this 4-bit value is the **elevation beam index** used (which sub-swath beam was active). If SSBFlag=1 (calibration pulse), these 4 bits are split into a **SAS test flag and Cal type** code, indicating the kind of calibration (e.g., internal calibration, external noise) and whether the SAS (antenna) test mode is enabled.
  * **Azimuth Beam Address / Calibration Beam Address** (10 bits) – If SSBFlag=0, a 10-bit **azimuth beam address** (or beam steering indicator) identifying the azimuth steering position for the pulse. If SSBFlag=1, a 10-bit **calibration beam address** specifying which antenna beam or calibration channel is being used for the cal pulse. (This could encode, for example, which antenna beam is being calibrated.)
  * **Calibration Mode** (2 bits) – For calibration/test pulses, this field further classifies the calibration type. For instance, different codes might represent noise measurement vs. internal loopback vs. external calibration target pulses. It is typically 0 for normal echoes and non-zero for various calibration sequences.
  * **TX Pulse Number** (5 bits) – Pulse number within a calibration sequence or burst. During special calibration sequences (like a burst of internal calibration pulses), this field can index the pulse (0–N) in that sequence. For normal imaging pulses, it may be 0 or increment within a burst pattern (if used for burst phasing).

* **Signal and Data Segment Info:**

  * **Signal Type** (4 bits) – Identifies the type of signal recorded in the user data of this packet. For Sentinel‑1, this could label the packet as containing a **normal echo**, **noise-only data**, **calibration echo**, etc., complementing the other flags. For example, one code might mean “SAR echo data” while another means “noise measurement” (when the transmitter was off).
  * **Spare (thirdSpare3Bit)** (3 bits) – Unused bits for alignment in this section.
  * **SWAP Flag** (1 bit) – Indicates if I/Q ordering was swapped or some byte order anomaly. In some SAR missions a swap flag is used if the two bytes of a sample or I and Q channels were reversed; here it’s likely a fixed value (ensuring consistent interpretation of the sample byte order).
  * **Swath Number** (1 byte, uchar) – The **sub-swath identifier** for this pulse. This is especially important in multi-swath modes like IW or EW. Each sub-swath (beam) in IW/EW is assigned a swath code – e.g., in IW mode the three subswaths might be coded as 10, 11, 12 for IW1, IW2, IW3 echo pulses. Calibration pulses related to those swaths have their own codes (e.g., 60, 61, 62 for IW1/IW2/IW3 TX calibration pulses in one configuration) as defined in the radar database. The swathNumber field thus tells processors which sub-swath a given echo belongs to, enabling separation of the data by beam. (In Stripmap mode, which has a single beam, this field may still be present but fixed to a single value.)
  * **Number of Quads (numOfQuads)** (2 bytes, ushort) – The count of **complex sample pairs** (I/Q pairs) in the packet’s data block. This essentially equals the number of range samples collected for that pulse (after any onboard compression). For a given SWL (window length) and sampling rate, this number is expected to be constant for all standard echo packets; however it might differ for calibration packets if they use shorter sampling windows. Recording this count is useful for verification and for reconstructing the slant-range length of each echo.
  * **Filler Octet** (1 byte) – A padding byte to align the end of the secondary header to a 62-byte boundary. This byte is typically unused (`0x00`) and simply ensures that the combined secondary header length is an even multiple of bytes (accounting for the bit-field sections above).

In total, the secondary header is 62 bytes, bringing the total header (primary + secondary) to 68 bytes per packet. Every field in this header has a defined purpose in relation to SAR imaging, as described. Notably, **timing fields** (coarse/fine time, PRI count) tie each packet to an absolute time grid; **geometry fields** (swath number, beam addresses, SWST/SWL) map pulses to the imaged swath and range window; and **instrument configuration fields** (instrument ID, BAQ mode, gain, calibration flags) capture how the radar was configured for that pulse, which is essential for proper data decoding and calibration.

**Figure: Structure of a Sentinel‑1 Level‑0 RAW packet (ISP)** – The primary header (6 bytes) is followed by the secondary header (62 bytes), then the compressed radar samples in the user data field. Key fields in the headers are indicated (timestamps, IDs, lengths, etc.), and the user data contains BAQ-compressed I/Q samples.



### 1.3 User Data Field (BAQ-Compressed Radar Samples)

After the headers, each packet’s **user data field** contains the radar echo samples for that pulse, compressed using Sentinel‑1’s onboard quantization scheme. The Packet Data Length field in the primary header tells us how many bytes of user data are present (by subtracting the known secondary header size). Key aspects of the user data:

* **I/Q Sample Format:** Sentinel‑1 digitally records the complex baseband echo (In-phase and Quadrature channels) for each pulse. Prior to transmission, these samples are quantized and compressed. Originally, the ADC samples are 8-bit (per I or Q) with high sample rates (e.g. 100 MHz for High-Resolution modes), resulting in a large raw data volume.

* **BAQ Compression:** To reduce data, the satellite applies **Block Adaptive Quantization (BAQ)**. In BAQ, blocks of echo samples are analyzed for their statistical properties, and an optimal quantization (e.g. 3-bit or 4-bit per sample) is chosen for each block to compress the data while maintaining SNR. Sentinel‑1 can operate in 3-bit, 4-bit, or 5-bit BAQ modes; it also has *Flexible Dynamic BAQ* modes (FDBAQ) that adjust quantization on the fly. The **BAQMode** field in the secondary header signals which scheme was used (e.g., a code for 3-bit BAQ, 4-bit BAQ, etc.). If Huffman coding is used for entropy coding of quantized blocks, that is also encompassed in the BAQ mode.

* **Data Packing:** The compressed samples are packed bit-contiguously. The **BAQBlockLength** (in samples) is given in the header, which, combined with the BAQ mode, tells how to parse the bitstream. For example, if BAQBlockLength = 64 and BAQ mode = 3-bit, each block of 64 I (and 64 Q) samples would be compressed to 3 bits each plus some Huffman overhead. The **Number of Quads** field provides the count of I/Q pairs so that the decoder knows how many samples to reconstruct. Typically, all echo packets in a given sub-swath have the same number of samples and thus the same user data length (since SWL is constant), but calibration packets (with shorter SWL or different BAQ settings) may have a different user data size. The **variableSizeFlag** in the index (see later) will indicate if packet sizes vary within a segment.

* **Contents:** For a normal echo pulse, the user data represents a segment of the received echo signal (after demodulation to baseband), starting at SWST delay and spanning SWL length. For a **noise pulse** (where the transmitter is off and the receiver records background noise), the user data will be noise samples (used for thermal noise calibration). For an **internal calibration pulse**, the user data contains the response of the internal calibration loop (or a calibration target) rather than ground echoes. The **signalType and calibration flags** in the header let the processor know how to interpret the user data – e.g., to exclude noise pulses from image formation and instead use them to estimate noise floor, or to use internal cal pulses for radiometric calibration.

In summary, the `.dat` file is essentially a concatenation of these structured packets. The binary format is highly efficient and **self-describing** in the sense that each packet carries the metadata needed to decode and place that pulse in the overall SAR image context. A processor reading this file would parse 68-byte headers, use the header info (particularly time stamps, swath ID, etc.) to determine where that pulse fits, then decompress the sample data block according to BAQMode to retrieve the I/Q values for image processing.

## 2. Metadata and Annotation Schema Structure (XSD Definitions)

The Sentinel‑1 Level‑0 product provides XML Schema definitions (`.xsd` files) that formally capture the structure of the binary components described above. These schema files, annotated with special **SDF (Structured Data Format) markup**, act as a blueprint for decoding – they define each field’s name, type, bit-length, and order in the binary files. The key schema files are:

* **`s1-level-0.xsd`** – Measurement Data Component schema (for the main `.dat` file structure).
* **`s1-level-0-annot.xsd`** – Annotation Data Component schema (for the annotation `.dat` structure).
* **`s1-level-0-index.xsd`** – Index Data Component schema (for the index `.dat` structure).

These XSD files reside in the product’s `support/` directory and are referenced by the manifest. They adhere to the Sentinel SAFE standard for binary data description, where each field is defined as an XML schema type with attributes specifying its size (in bits or bytes) and encoding. Below we explain the schema content and how it maps to physical SAR parameters:

### 2.1 Measurement Data Schema (`s1-level-0.xsd`)

The measurement schema describes the structure of the raw measurement `.dat` file – essentially defining the ISP packet layout discussed in section 1. It breaks down the packet into XML schema types corresponding to the headers and data field:

* **Primary Header Structure:** In the schema, the primary header is represented by elements for each field: e.g., `<xs:element name="packetVersionNumber" type="xs:unsignedByte" sdf:bitLength="3"/>`, `<xs:element name="packetType" sdf:bitLength="1"/>`, etc. Table 3-10 of the ESA product format specification shows these fields and their sizes. For instance, `packetVersionNumber` is 3 bits, `packetType` 1 bit, `secondaryHeaderFlag` 1 bit, `PID` 7 bits, `PCAT` 4 bits, `sequenceFlags` 2 bits, `packetSequenceCount` 14 bits, and `packetDataLength` 16 bits. In the schema, some of these might use base types like `xs:unsignedShort` with a total length, but with SDF annotations indicating the bit partitioning. Each field’s name in the schema corresponds closely to the descriptive name in the SAR spec (e.g., `PID` for Process ID).

* **Secondary Header Structure:** The schema then defines a complex type for the secondary header, grouping fields as per the defined order. Key fields such as `coarseTime`, `fineTime`, `dataTakeID`, `instrumentConfigurationID`, etc., appear as elements of specific numeric types (uint, ushort, etc.) with fixed byte lengths matching the spec. Bit-field sections (like the 1-bit flags and 3-bit/4-bit fields) are handled by combining them into an enclosing type or by using SDF bit-length annotations on sequential elements. For example, in the schema there may be an `<xs:element name="RXChannelID" sdf:bitLength="4"/>` immediately following a `<xs:element name="testMode" sdf:bitLength="3"/>` and a `<xs:element name="firstSpareBit" sdf:bitLength="1"/>`, ensuring those three together occupy one byte. Similarly, fields under the *SAS SSB Message* section (like `ssbFlag`, `polarisation`, `calMode`, etc.) are defined with their respective bit lengths and combined appropriately. The schema effectively mirrors the layout given in the specification tables, so each field in the binary packet has a corresponding schema element with the same size.

* **User Data Field Definition:** The measurement schema also includes a representation of the variable-length user data. In practice, this might be defined as an element like `<xs:element name="userData" type="xs:hexBinary" sdf:lengthExpression="packetDataLength+1 - SecondaryHeaderLength"/>` or similar, using an expression to tie the length to the `packetDataLength` from the primary header. Essentially, the schema uses the length field to determine how many bytes of echo data follow the headers. The schema doesn’t decode BAQ itself (that is left to user processing), but it marks this field as a byte array of the appropriate length.

* **Record (Packet) Sequence:** The entire `.dat` file structure is defined as a sequence of these packet records. The schema likely has a top-level container (e.g., `<xs:element name="measurementDataFile">`) which contains either an unbounded sequence of `ISP_Record` elements, or an xs\:complexType with `<xs:sequence maxOccurs="unbounded">` of the packet type. In other words, it indicates that the measurement file consists of repeated packets of this structure. The SAFE format relies on external iteration (and the index file) for reading, but the schema logically allows one to validate the structure of each record.

In summary, `s1-level-0.xsd` provides a **formal blueprint of the binary packet format**, listing each field name, its data type (often custom types for 1-byte, 2-byte unsigned, etc.), and exact size. This is extremely useful for developers, as it aligns with the SAR specification: for instance, a developer can see that `swathNumber` is defined as an 8-bit unsigned integer in the schema (1 byte) and know it corresponds to the sub-swath code as described earlier. The schema also references the *Space Packet* spec document for meaning of fields (via annotations or documentation), but the key physical parameters (time stamps, beam IDs, etc.) are directly evident from the element names. By using the schema, software tools can automatically parse or validate the binary file structure, ensuring each field is read correctly according to the Sentinel‑1 specification.

### 2.2 Annotation Data Schema (`s1-level-0-annot.xsd`)

The Annotation Data Component is essentially a distilled version of the measurement data – it contains one record per ISP but **only the header information** (no signal samples). In other words, each annotation record is 68 bytes long (6-byte primary + 62-byte secondary header) exactly matching the header of the corresponding measurement packet. The purpose is to allow quick access to timing and status info for each pulse without reading the large sample data.

The schema `s1-level-0-annot.xsd` therefore defines a record that is almost identical to the measurement packet schema **minus the user data field**. According to the ESA documentation, the annotation schema uses the same type definitions as the measurement schema for the primary and secondary header fields, excluding the `userData` type. Key points:

* The annotation record includes all the fields described in section 1.2 (Packet Primary Header and Secondary Header). Thus, in the schema we see the same elements: `packetVersionNumber`, `PID`, `coarseTime`, `PRICount`, `swathNumber`, etc., with identical sizes and types.

* The schema likely reuses the complex types from `s1-level-0.xsd` for the header structure. (The SAFE format allows schema import or reuse, or they may have duplicated the definitions with the same SDF markup.)

* **No UserData:** The crucial difference is that after the last header field (`fillerOctet`), the annotation record ends. There is no `userData` element in this schema, since the annotation file doesn’t contain the radar sample data. Each record is fixed-length 68 bytes. The schema might explicitly set the record length or simply omit any variable-length constructs.

* The annotation `.dat` file is structured as a sequence of these fixed-length records, one per source packet. The schema thus will have an unbounded sequence of the annotation record type (similar to measurement). Each annotation record corresponds by index to a measurement packet in the main data file (i.e., record N in annotation file is the header of record N in measurement file).

By consulting `s1-level-0-annot.xsd`, a developer learns the **hierarchical structure of the annotation file**: e.g., an `<AnnotationRecord>` with child elements for `primaryHeader` and `secondaryHeader` fields. The “key tags” here are those field names – the same as we’ve discussed (coarseTime, instrumentConfigurationID, etc.). These map exactly to the physical SAR parameters of each pulse, allowing quick extraction of, say, all pulse timestamps or all PRF counts without parsing the full data. For example, if one wants to plot how the PRF or SWST varies throughout an IW data-take, the annotation file (via the schema) provides direct access to those fields per pulse.

In summary, the annotation schema is a streamlined version of the measurement schema, capturing **per-pulse metadata**. It is particularly tied to physical SAR parameters like timing and calibration events – e.g., a calibration pulse will appear in the annotation records with SSBFlag=1 and a specific calMode, so a processor can identify it immediately. The schema ensures these fields are correctly extracted. (ESA sometimes refers to the annotation product as a form of “timeline” product since it encapsulates the sequence of operations during the acquisition.)

### 2.3 Index Data Schema (`s1-level-0-index.xsd`)

The Index Data Component provides higher-level grouping of the measurement data for efficient access. Instead of per-pulse entries, it divides the data into **logical blocks** (segments) and describes each block. Typically, a “block” might correspond to a continuous series of pulses with consistent properties (e.g., a burst, or a contiguous segment of echo pulses between calibration gaps). The index file significantly accelerates data access by allowing software to jump to byte offsets for particular time intervals or bursts without sequentially scanning every packet.

The schema for the index (`s1-level-0-index.xsd`) defines a **block descriptor** structure, repeated for each block. According to Table 3-12 of the spec, each block descriptor is 36 bytes long and contains the following key fields:

* **dateAndTime** (8 bytes, double) – The acquisition time of the first ISP in the block, in absolute terms (UTC). The time is expressed as a double-precision float in **Modified Julian Date 1950** format (days since 1950 plus fractional day). This gives a precise timestamp for the block start. (This is effectively the time of a specific pulse, converted from coarseTime/fineTime of that packet into a standard time reference by ground processing.)
* **deltaTime** (8 bytes, double) – The time interval between ISPs in this block. Essentially, this is the pulse repetition interval (PRI) for pulses within the block, expressed in milliseconds (with fractional part). This value is constant for a block if all pulses are evenly spaced (e.g., within a burst). If the block covers a burst of IW mode, deltaTime would equal the PRI during that burst. For a block that includes a gap or non-uniform spacing, this field might be used differently (or an average), but the spec suggests it’s applicable within the block (implying uniform PRF in each block).
* **deltaSize** (4 bytes, unsigned int) – The size in bytes of each ISP in the block, if they are uniform. If `variableSizeFlag=0` (see below), all packets in the block are the same size and this field gives that size. If `variableSizeFlag=1`, meaning packet sizes vary in this block, then `deltaSize` is valid only for the first ISP (and for subsequent ISPs one would need to inspect their headers individually). In practice, a block with variable sizes likely corresponds to a segment where different pulse types are interleaved (e.g., a block that includes both echo and calibration packets which might be shorter).
* **dataUnitsOffset** (4 bytes, unsigned int) – The index (count) of the first ISP of this block, relative to the start of the measurement data file. For example, if dataUnitsOffset = 100, it means the block begins at the 100th packet in the file. This allows quick calculation of the packet sequence number range covered by the block.
* **byteOffset** (8 bytes, unsigned long) – The byte position in the measurement `.dat` file of the start of this block. This is the file seek offset to jump to when accessing the first packet of the block. Using this, software can directly seek to that file position rather than scanning through all prior data. (The need for 8 bytes indicates the file can be very large, >4GB in worst cases, so a 64-bit offset is provided.)
* **variableSizeFlag** (1 byte, boolean) – A flag indicating whether the ISPs in this block have variable sizes (`1`) or all the same size (`0`). If 0, one can use `deltaSize` and the count of pulses to know exactly how large the whole block is (and each ISP within). If 1, the block likely contains mixed types and one may need to read each packet’s header to find boundaries (the index still gives start offset and first packet size in that case).
* **spare** (3 bits) – Padding bits to align the structure to 36 bytes total. (The remaining 5 bytes of this last index word might be reserved or zero-filled to complete alignment; the spec explicitly notes 3 bits spare since `variableSizeFlag` is effectively 1 bit in size field.)

The index schema will define something like a `<BlockDescriptor>` complex type with the above fields as elements or attributes, each with fixed size. For instance, `dateAndTime` could be an `xs:double`, `deltaTime` an `xs:double`, etc., matching the sizes. The schema likely uses semantic names similar to those above, mapping directly to their meaning (the spec description is quite clear on these names).

The top-level of the index file is a sequence of block descriptors. The number of blocks is not fixed; it depends on how the data can be segmented. For a typical IW slice of \~25 seconds, one might have dozens or hundreds of blocks. For example, each burst in IW (with a gap after it) might be a block. The spec hints that the number of blocks is driven by efficiency – too many small blocks would bloat the index, too few large blocks reduce granularity. In practice, blocks often correspond to natural breaks: e.g., *preamble* (calibration block), then *bursts* or continuous segments of echo, then calibration segments, etc.

**How these map to SAR acquisition:** The index fields are directly tied to physical segments of the acquisition timeline:

* The **dateAndTime** (UTC) of first ISP in block could be, for instance, the start time of a TOPS burst or the time of a standalone wave mode segment. This allows quick temporal locating of segments.
* The **deltaTime** essentially gives the PRF of that block (e.g., 2.5 ms PRI), which might indicate whether the block is a high-PRF echo segment or a low-rate calibration segment. If a block contains the noise pulses of a preamble (often a slower rate), the deltaTime would reflect that accordingly.
* **deltaSize** indicates whether, for example, the block is all echo pulses of identical size (as expected in a uniform swath) or if not (suggesting a mix, possibly a calibration interleaved sequence).
* The **variableSizeFlag** being 1 is a clue that the block likely contains different pulse types (e.g., a stretch where an internal calibration pulse is inserted every Nth pulse, causing alternating packet sizes). In Sentinel‑1 IW, for instance, during a burst sequence there might be periodic calibration pulses (with shorter window) inserted – the index might either split those into separate blocks or mark the block as variable size if they keep them together.
* **Offsets (dataUnitsOffset and byteOffset)** simply tie back to the file positions, but by comparing offsets of consecutive blocks one can calculate how many packets are in a block and how large the block is. This correlates to how many pulses were in that segment of the timeline.

The `s1-level-0-index.xsd` schema thus provides a high-level map of the measurement file. A developer can use it to parse the index `.dat` and get an array of block descriptors. For example, if one wants to extract only IW sub-swath 2 bursts, the index can be scanned for blocks where swathNumber (the first packet’s swathNumber, one might infer) equals the code for IW2. Or, more directly, one could find the time window of each block and correlate it with burst times known from PRF and burst length.

To illustrate, an **IW mode** Level-0 slice might produce an index with blocks such as: Block1 = preamble (containing a few noise pulses, variable sizes, short duration), Block2 = IW1 burst 1 (all echo pulses, uniform size), Block3 = IW2 burst 1, Block4 = IW3 burst 1, then maybe a calibration block, then Block5 = IW1 burst 2, etc. Each block’s first pulse time and size are known from the index, so a processor can jump straight to, say, IW3 by looking for the block with swathNumber 12 (IW3 code) and using its byteOffset.

Overall, the index schema is not tied to a specific SAR “physical” parameter in the way the measurement/annotation schemas are, but rather to *organizational parameters* (time and length of segments). Still, these have clear relationships to the acquisition timeline: **dateAndTime** relates to pulse time (hence orbit position), **deltaTime** relates to PRF (hence mode), and the segmentation often reflects bursts or calibration periods inherent in the SAR mode.

## 3. Mode-Specific Format Nuances and Notable Details

The Sentinel‑1 Level‑0 RAW format is largely uniform across modes, but there are some nuances to note for different acquisition modes and polarizations, as specified by ESA:

* **Stripmap vs. Interferometric Wide Swath (IW) vs. Extra-Wide (EW) Modes:** The primary difference is the use of sub-swaths. In Stripmap (SM), there is only one continuous swath (S1, S2, etc., depending on beam pointing). The swathNumber field in each packet will correspond to that single beam (e.g., S1 might be coded as `1`). In IW and EW, multiple elevation beams are interleaved. The swathNumber field **changes value pulse-to-pulse** as the instrument cycles through sub-swaths IW1, IW2, IW3 (for IW mode) or EW1..EW5 (for EW mode). For example, an IW mode product will show swathNumber values 10, 11, 12 in the secondary headers, denoting pulses belonging to IW1, IW2, and IW3 respectively. This allows the ground processor to separate the pulses by sub-swath and assemble three sub-swath data streams for focusing. The exact numeric codes for swaths are defined in the radar database, but as an example IW1=10, IW2=11, IW3=12 for echo pulses in one configuration (with different ranges like 60+ for calibration pulses as seen in the table). The **instrumentConfigurationID** also reflects the mode; for TOPS modes (IW/EW) it corresponds to a configuration that includes burst scheduling, but it remains constant through the bursts (the swathNumber is the dynamic indicator per pulse). Additionally, fields like SWST may differ per swath – e.g., IW3 pulses (far range) have a larger SWST than IW1 pulses, since the near range vs far range echo return times differ. This per-pulse variation is captured in the secondary header of each packet.

* **Burst and PRF Changes:** In TOPS (IW/EW) mode, the PRF can have slight adjustments between bursts or during calibration gaps. The index can segment bursts, but also within the packet headers the PRI count and coarse time will show discontinuities at burst boundaries (since between bursts there’s a longer gap). Also, a field like **rank** (5 bits, in the Radar Config section) might indicate the burst number or position in a burst sequence (though the exact usage of “rank” is not explicitly described above, it could be related to burst indexing in certain modes if used). The **timeline** is complex: as the spec indicates, an IW timeline has a *preamble* (with noise pulses and initial calibration) and then repetitive burst cycles for each subswath. The Level‑0 format faithfully includes all these, so one will find that the first few packets of a slice are noise pulses (signalType likely denoting noise, and calibration flags set for internal cal pulses that follow) – these correspond to that preamble.

* **Calibration Pulses and Modes:** Sentinel‑1 periodically injects calibration pulses even during imaging. There are at least a few types: Internal calibration (where the TX signal is routed to the receiver via a calibration loop), External calibration (receiving a calibration tone or load), and Noise (with TX off to measure noise floor). These are indicated by **SSBFlag=1 and calMode codes** in the packet headers. For example, during standard data-takes, one common pattern is to have a noise pulse and an internal calibration pulse at the start, and then periodically (e.g., every 100 pulses) another calibration pulse. These pulses will have shorter SWL (since they may not record the full echo window) and possibly different BAQ settings. The Level‑0 format handles this by simply marking them appropriately in the header and allowing their smaller data length (the variable packet sizes). The ground processing can identify them via the header: e.g., a packet with polarisation field but a calMode indicating “internal loop cal” – that packet’s user data is not an Earth echo and should be excluded from image formation, but used for calibration computations. The presence of these calibration pulses is a nuance that algorithms must handle. The format specification ensures they are clearly flagged. For instance, a cal pulse might have SSBFlag=1, and specific *ElevationBeamAddress or CalType* bits and a non-zero calMode, and often the **swathNumber might use a special code** (as seen in the mapping table: e.g., TxCal for IW1 might use code 60). Also, **signalType** could differentiate a noise-only packet vs. a normal echo; if the transmitter was off (noise measurement), presumably a certain signalType code is used while calMode might indicate noise.

* **Dual-Polarization Considerations:** In dual-pol acquisitions (e.g., HH+HV or VV+VH), Sentinel‑1 alternates transmit polarization or uses simultaneous receive channels. The raw product is delivered as two separate `.dat` files (MDCs) – one per polarization channel. Typically for Sentinel‑1, this means one file contains all pulses recorded on the co-polarized channel and the other contains the cross-polarized channel. The primary headers in these files will have different APIDs to distinguish them. Within the packet secondary headers, the **RXChannelID** will usually be constant in a given file (identifying that channel), and the **polarisation field** will also reflect the polarization for that channel’s pulses (e.g., all packets in one file might have polarization code for “HH” and the other file “HV”). The instrument timeline for dual-pol is often that the satellite transmits one polarization (say H) and receives on two channels (H and V) simultaneously – effectively yielding two packets per pulse time, one for each channel. However, Sentinel‑1’s design actually interleaves pols pulse-to-pulse (Tx H then Tx H again, or Tx alternating H/V depending on mode). Regardless, the ground product separates them. Developers should note that **for dual-pol, there will be two annotation files and two index files as well**, corresponding to each data file. The schema definitions remain the same, but one can correlate pulses between polarizations via their timestamps (the coarse/fine time). If truly simultaneous, two packets (one per pol) will share the same timestamp; if alternating, timestamps will be interleaved. The Level‑0 format supports both – each packet’s pol is explicit, and separate files prevent any ambiguity.

* **Product Classes (Standard vs Calibration/Noise):** While the question focuses on RAW products in general, it’s worth noting that ESA defines separate Level‑0 product “classes.” A **Standard L0 product** (product type `RAW`) contains primarily the imaging data (with embedded calibration pulses as described). There are also special L0 products for calibration and noise, which might be delivered when the satellite does dedicated calibration acquisitions. For instance, a **Calibration L0 product** would contain only calibration pulses extracted (and its product identifier uses class “*CAL*”), and a **Noise L0 product** contains only noise pulses (class “*NOISE*”). The format of those is essentially the same, but some components are omitted (e.g., an all-calibration product might not include an index or might not slice the same way because it’s small, as indicated in the spec). The schemas we discussed apply similarly to those, but their content (swath numbers, cal flags) will be consistently set for calibration types. For a developer, the takeaway is that a “RAW” product typically refers to the standard imaging product (with some calibration pulses included), whereas pure calibration datatakes would be rare for general users.

* **Slicing and Overlaps:** The Level‑0 slicing (often 25s chunks) means that a long acquisition is split. The first and last slice of a data-take may contain partial patterns (e.g., the first slice includes the initial calibration preamble, the last slice might end partway through a burst cycle). The overlapping few seconds ensure continuity for Level‑1 processing. From a format perspective, slices are independent SAFE products – so each slice has its own sequence counts starting at 0, its own annotation and index. This is relevant if one tries to chain pulses across slices: you must use the absolute times (from annotation or index) to link them, rather than sequence counts. The index’s first block in a slice will indicate if it did **not** start at a natural timeline boundary (the index’s first block could start with a partial burst if the slice cut through one). In any case, the format does not explicitly mark “slice boundaries” inside the data (since each slice is separate), but developers should be aware of them when processing multiple slices of one acquisition.

In conclusion, Sentinel‑1 Level‑0 RAW products provide a **rich, detailed representation of the SAR instrument’s output**. The `.dat` files’ binary structure encodes every pulse with precise time, configuration, and calibration info, while the accompanying annotation and index files (and their XSD schemas) map this structure for user interpretation. By following the ESA Product Format Specification and using the schema definitions, a developer can reliably decode the RAW data: reconstructing the sequence of radar echoes and calibration pulses and preparing them for focused image formation or analysis. All the critical SAR acquisition parameters – timing (PRF), geometry (swath/beam), radiometric adjustments (gain, BAQ), and calibration events – are encapsulated in the Level‑0 format, making it a self-contained record of the radar sensing needed to generate higher level SAR products.

**Sources:**

1. Sentinel‑1 Level‑0 Product Format Specification, ESA (Issue 3.1, 2023) – official definition of RAW product binary structure.
2. Sentinel‑1 Level‑0 Data Decoding Package, ESA (2020) – technical note with decoding guidance.
3. Sentinel‑1 SAR Space Packet Protocol (Instrument Source Packet structure) – details of primary/secondary header fields and SAR-specific headers.
4. Copernicus Sentinel‑1 Product Definition (2016) – descriptions of product types, slicing, and annotation content for L0/L1 products.
5. SAR-MPC Technical Documentation (2025) – references to Sentinel‑1 SAFE format and product components.

href{https://sentiwiki.copernicus.eu/__attachments/1673968/S1PD.SP.00110.ATSR%20-%20Sentinel-1%20Level-0%20Product%20Format%20Specifications%202023%20-%203.1.pdf#:~:text=Header%20packetVersion%20Number%20Packet%20Version,Type%201%20bit%20secondaryheader%20Flag}

https://sentiwiki.copernicus.eu/__attachments/1673968/S1PD.SP.00110.ATSR%20-%20Sentinel-1%20Level-0%20Product%20Format%20Specifications%202023%20-%203.1.pdf#:~:text=coarseTime%20Coarse%20Time%20uint%204,Hex%20array%204%20bytes%20dataTakeID

https://sentiwiki.copernicus.eu/__attachments/1673968/S1PD.SP.00110.ATSR%20-%20Sentinel-1%20Level-0%20Product%20Format%20Specifications%202023%20-%203.1.pdf#:~:text=dateAndTime%20Acquisition%20time%20of%20the,for%20all%20the%20ISPs%20in

https://sentiwiki.copernicus.eu/__attachments/1673968/S1PD.SP.00110.ATSR%20-%20Sentinel-1%20Level-0%20Product%20Format%20Specifications%202023%20-%203.1.pdf#:~:text=coarseTime%20Coarse%20Time%20uint%204,Hex%20array%204%20bytes%20dataTakeID

https://sentiwiki.copernicus.eu/__attachments/1673968/S1PD.SP.00110.ATSR%20-%20Sentinel-1%20Level-0%20Product%20Format%20Specifications%202023%20-%203.1.pdf#:~:text=ssbFlag%20SSB%20Flag%201%20bit,bits%20elevationBeam%20Address%20Elevation%20Beam

https://www.researchgate.net/publication/344439534_Sentinel-1_Level-0_Data_Decoding_Package#:~:text=3.2%20Level

https://www.researchgate.net/publication/344439534_Sentinel-1_Level-0_Data_Decoding_Package#:~:text=%E2%80%A2%20A%20Manifest%20,overall%20context%20a%20nd%20content

https://www.researchgate.net/publication/344439534_Sentinel-1_Level-0_Data_Decoding_Package#:~:text=%E2%80%A2%20Index%20%20Data%20Components,MDC%20and%20containing%20%20the

https://sar-mpc.eu/

