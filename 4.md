# Detailed Step-by-Step Documentation: Sentinel-1 SAR Data Processing System

This system processes raw Sentinel-1 SAR (Synthetic Aperture Radar) satellite data files and decompresses them into usable I/Q (In-phase/Quadrature) radar samples. Let me walk through every component in detail.

## Overall System Architecture

**Step 1: Input** - Raw Sentinel-1 `.dat` files containing compressed radar data packets
**Step 2: Packet Parsing** - Extract headers and payload data from each packet  
**Step 3: Data Type Detection** - Determine if data is calibration (uncompressed) or echo (compressed)
**Step 4: Processing** - Apply appropriate decompression algorithm
**Step 5: Output** - Write I/Q samples to binary files for further SAR processing

---

## Main Processing Loop (read_file.c)

### File Opening and Initialization

**Step 1: Command Line Validation**
```c
if (argc<2) return(1);
```
- Checks if user provided a filename argument
- Exits if no input file specified

**Step 2: File Opening**
```c
f=fopen(argv[1],"r");
```
- Opens the Sentinel-1 raw data file in binary read mode
- This file contains multiple data packets concatenated together

**Step 3: Variable Initialization**
```c
static unsigned char tablo[65536];  // Buffer for packet data
float IE[52378], IO[52378], QE[52378], QO[52378];  // Output arrays for I/Q samples
char brc[52378];  // Buffer for compression parameters
```
- `tablo`: Large buffer to hold one complete packet (up to 64KB)
- `IE/IO/QE/QO`: Arrays to store the four radar data channels
- `brc`: Stores compression level information for each data block

### Packet Header Processing Loop

**Step 4: Primary Header Reading (6 bytes total)**
```c
fread(&c,2,1,f);    // Read first 2 bytes
c=ntohs(c);         // Convert from network byte order
Secondary=(c>>11)&0x01;  // Extract secondary header flag
PID=(c>>4)&0x7f;         // Extract packet ID
PCAT=(c)&0xf;            // Extract packet category
```
- Reads SAR Space Protocol Data Unit header
- `ntohs()`: Converts big-endian (network) to little-endian (host) byte order
- Bit shifting extracts specific fields from the 16-bit word

**Step 5: Sequence Control Reading**
```c
fread(&c,2,1,f);    // Read bytes 3-4
c=ntohs(c);
Sequence=(c>>14);   // Extract sequence flags
Count=(c&0x3f);     // Extract packet counter
```
- `Sequence`: Indicates if packet is first/middle/last in sequence
- `Count`: Sequential packet counter for ordering

**Step 6: Data Length Reading**
```c
fread(&c,2,1,f);    // Read bytes 5-6
DataLen=ntohs(c)+1; // Data length (add 1 per protocol)
```
- `DataLen`: Number of bytes in the packet payload
- Used to allocate buffer space and validate packet integrity

**Step 7: Payload Reading**
```c
res=fread(tablo,1,DataLen,f);
```
- Reads the entire packet payload into `tablo` buffer
- `res`: Number of bytes actually read (for error checking)

### Secondary Header Processing (62 bytes)

**Step 8: Timing Information Extraction**
```c
tmp32=*(uint32_t*)tablo;Time=ntohl(tmp32);        // Coarse time (4 bytes)
tmp16=*(uint16_t*)(tablo+4);tmp16=ntohs(tmp16);   // Fine time (2 bytes)
```
- `Time`: GPS seconds since epoch when data was acquired
- Fine time: Sub-second precision (multiplied by 2^-16 seconds)
- Critical for geolocation and Doppler processing

**Step 9: Sync Marker Validation**
```c
tmp32=*(uint32_t*)(tablo+6);tmp32=ntohl(tmp32);
if (tmp32!=0x352EF853) printf("\nERROR: Sync marker != 352EF853");
```
- Verifies data integrity using fixed sync pattern
- If sync marker is wrong, packet is corrupted

**Step 10: Instrument Configuration Reading**
```c
printf("\tWordIndex=%02hhx",*(uint8_t*)(tablo+20)); // Attitude/orbit data index
tmp16=*(uint16_t*)(tablo+21);tmp16=ntohs(tmp16);    // Attitude/orbit data value
```
- Reads spacecraft attitude and orbit information
- This data accumulates across 64 packets to build complete state vectors

**Step 11: Radar Configuration Extraction**
```c
BAQ=(*(uint8_t*)(tablo+31))&0x1f;       // Compression mode
Typ=(*(uint8_t*)(tablo+57));Typ=Typ>>4; // Signal type  
Swath=(*(uint8_t*)(tablo+58));          // Beam/swath number
NQ=*(uint16_t*)(tablo+59);NQ=ntohs(NQ); // Number of I/Q pairs
```
- `BAQ`: Compression algorithm (0x00=bypass, 0x0c=FDBAQ)
- `Typ`: Data type (0=echo data, >7=calibration)
- `Swath`: Which radar beam was used (different ground coverage)
- `NQ`: Number of complex samples in this packet

### Output File Management

**Step 12: File Creation Logic**
```c
if ((Swath!=file_swath_number)||(file_nq!=NQ))
{
    if (file_swath_number!=0)
    {
        close(result);close(brcfile);  // Close previous files
    }
    sprintf(filename,"resultSW%02d_T%d_NQ%d.bin",Swath,Time,NQ);
    result=open(filename,O_WRONLY|O_CREAT|O_TRUNC,0644);
    sprintf(filename,"brcSW%02d_T%d.bin",Swath,Time);
    brcfile=open(filename,O_WRONLY|O_CREAT|O_TRUNC,0644);
}
```
- Creates new output files when swath or sample count changes
- Filename includes swath number, timestamp, and sample count for organization
- `O_TRUNC`: Overwrites existing files with same name

### Data Processing Dispatch

**Step 13: Processing Path Selection**
```c
user=(uint8_t*)(tablo+62);  // Point to start of radar data
```
- `user`: Pointer to actual radar data (after 62-byte header)

**Step 14: Calibration Data Path**
```c
if ((BAQ==0x00)&&(Typ>7))    // Uncompressed calibration
{
    cposition=bypass(user,NQ,IE,IO,QE,QO); 
    for (cal_p=0;cal_p<NQ;cal_p++) 
    {
        write(result,&IE[cal_p],sizeof(float));  // Write I-even
        write(result,&QE[cal_p],sizeof(float));  // Write Q-even  
        write(result,&IO[cal_p],sizeof(float));  // Write I-odd
        write(result,&QO[cal_p],sizeof(float));  // Write Q-odd
    }
}
```
- Calibration signals are uncompressed, just bit-packed
- Calls `bypass()` function to unpack 10-bit values
- Writes results as 32-bit floats in IEQEIOQO order

**Step 15: Echo Data Path**
```c
if ((BAQ==0x0c)&&(Typ==0))   // FDBAQ compressed echo data
{
    brcpos=0;
    cposition=packet_decode(user,NQ,IE,IO,QE,QO,brc,&brcpos); 
    for (cal_p=0;cal_p<NQ;cal_p++) 
    {
        write(result,&IE[cal_p],sizeof(float));
        write(result,&QE[cal_p],sizeof(float));
        write(result,&IO[cal_p],sizeof(float));
        write(result,&QO[cal_p],sizeof(float));
    }
    for (cal_p=0;cal_p<brcpos;cal_p++) write(brcfile,&brc[cal_p],1);
}
```
- Echo data uses FDBAQ compression
- Calls `packet_decode()` for Huffman decompression
- Also saves compression parameters to separate BRC file

---

## Bypass Processing (bypass.c)

This function handles **uncompressed calibration data** that's packed as 10-bit values.

### Function Setup and Calculations

**Step 1: Function Entry**
```c
int bypass(unsigned char *p,int NQ,float* IE,float* IO ,float* QE,float* QO)
```
- `p`: Pointer to raw data bytes
- `NQ`: Number of complex I/Q pairs to extract  
- `IE,IO,QE,QO`: Output arrays for the four data channels

**Step 2: Data Layout Calculation**
```c
int NW=(10*NQ)/16*2;
```
- Calculates number of 16-bit words needed for NQ samples
- Each sample is 10 bits, so `10*NQ` total bits
- Divided by 16 bits per word, multiplied by 2 for word addressing

**Step 3: Variable Initialization**
```c
short res;           // Temporary result holder
int pos=0,sign,index=0;  // Position, sign flag, sample counter
```

### IE Channel Processing (In-phase Even)

**Step 4: IE Channel Loop Setup**
```c
while (index<(NQ))  // Process all NQ samples
```

**Step 5: First 10-bit Value Extraction (IE[0], IE[4], IE[8]...)**
```c
if (index<NQ) 
{
    res=(short)(p[pos+0]&0xff)*4+(short)(p[pos+1]>>6);    // Combine bytes
    sign=(res&0x200); res=res&(0x1ff); if (sign>0) res=-res; // Handle sign
    IE[index]=(float)res; 
    index++;
}
```
- Takes byte at `pos+0` (8 bits) and shifts left by 2 (`*4`)
- Adds top 2 bits from `pos+1` byte (`>>6`)
- Total: 10 bits combining `bbbbbbbb bb` pattern
- `0x200`: Checks bit 9 (sign bit for 10-bit two's complement)
- `0x1ff`: Masks to 9-bit magnitude
- Converts to negative if sign bit was set

**Step 6: Second 10-bit Value Extraction (IE[1], IE[5], IE[9]...)**
```c
if (index<NQ) 
{
    res=(short)(p[pos+1]&0x3f)*4*4+(short)(p[pos+2]>>4);   
    sign=(res&0x200); res=res&(0x1ff); if (sign>0) res=-res;
    IE[index]=(float)res; 
    index++;
}
```
- Takes bottom 6 bits from `pos+1` (`&0x3f`) and shifts left by 4 (`*4*4`)
- Adds top 4 bits from `pos+2` (`>>4`) 
- Pattern: `bbbbbb bbbb` across byte boundary

**Step 7: Third 10-bit Value Extraction (IE[2], IE[6], IE[10]...)**
```c
if (index<NQ) 
{
    res=(short)(p[pos+2]&0x0f)*4*4*4+(short)(p[pos+3]>>2);
    sign=(res&0x200); res=res&(0x1ff); if (sign>0) res=-res;
    IE[index]=(float)res; 
    index++;
}
```
- Takes bottom 4 bits from `pos+2` (`&0x0f`) and shifts left by 6 (`*4*4*4`)
- Adds top 6 bits from `pos+3` (`>>2`)
- Pattern: `bbbb bbbbbb` across byte boundary

**Step 8: Fourth 10-bit Value Extraction (IE[3], IE[7], IE[11]...)**
```c
if (index<NQ) 
{
    res=(short)(p[pos+3]&0x03)*4*4*4*4+(short)(p[pos+4]);
    sign=(res&0x200); res=res&(0x1ff); if (sign>0) res=-res;
    IE[index]=(float)res; 
    index++;
}
```
- Takes bottom 2 bits from `pos+3` (`&0x03`) and shifts left by 8 (`*4*4*4*4`)
- Adds all 8 bits from `pos+4`
- Pattern: `bb bbbbbbbb` across byte boundary

**Step 9: Position Increment**
```c
if (index<NQ) pos+=5;
```
- Moves to next 5-byte group containing next 4 samples
- 5 bytes = 40 bits = exactly 4 × 10-bit samples

### IO Channel Processing (In-phase Odd)

**Step 10: IO Channel Positioning**
```c
index=0;
pos=NW+2; // next short
```
- Resets sample counter
- Moves position past IE data plus 2-byte alignment

**Step 11: IO Channel Extraction**
```c
while (index<(NQ))  // Same extraction logic as IE
```
- **Steps 11-15**: Identical bit extraction pattern as IE channel
- Processes IO[0], IO[1], IO[2]... samples
- Same 5-byte grouping with 4 samples per group

### QE Channel Processing (Quadrature Even)

**Step 16: QE Channel Positioning**
```c
index=0;
pos=2*(NW+2); // next short
```
- Positions past both IE and IO data sections

**Step 17: QE Channel Extraction**
- **Steps 17-21**: Identical extraction pattern
- Processes QE[0], QE[1], QE[2]... samples

### QO Channel Processing (Quadrature Odd)

**Step 22: QO Channel Positioning**
```c
index=0;
pos=3*(NW+2); // next short
```
- Positions past IE, IO, and QE data sections

**Step 23: QO Channel Extraction**
- **Steps 23-27**: Identical extraction pattern
- Processes QO[0], QO[1], QO[2]... samples

**Step 24: Final Position Calculation**
```c
pos=4*(NW+2); // next short
return(pos);
```
- Calculates final position after all data
- Returns position for validation

---

## FDBAQ Packet Decoding (packet_decode.c)

This function handles **compressed echo data** using Huffman coding and reconstruction.

### Bit Manipulation Functions

**Step 1: Bit Extraction Function**
```c
int next_bit(unsigned char *p,int *cposition,int *bposition)
{
    int bit=((p[*cposition]>>(*bposition))&1);  // Extract single bit
    (*bposition)--;                             // Move to next bit position
    if ((*bposition)<0) {(*cposition)++;(*bposition)=7;} // Next byte
    return(bit);
}
```
- Extracts individual bits from byte stream
- `*cposition`: Current byte index  
- `*bposition`: Current bit position (7=MSB, 0=LSB)
- Returns single bit value (0 or 1)

**Step 2: THIDX Extraction Function**
```c
unsigned char get_THIDX(unsigned char *p,int *cposition,int *bposition)
{
    int res=0;
    int k;
    for (k=0;k<8;k++)
    {
        res=res<<1;                                    // Shift previous bits left
        res+=next_bit(p,cposition,bposition);          // Add new bit
    }
    return(res);
}
```
- Reads 8-bit threshold index values
- Builds result bit by bit, MSB first
- Used for scaling during reconstruction

### Huffman Decoding Functions

**Step 3: BRC Function (Huffman Tree Traversal)**
```c
static struct sh_code BRC(int BRCn,unsigned char *p,int *cposition,int *bposition)
```
- Decodes variable-length Huffman codes
- `BRCn`: Compression level (0-4, higher = more compression)
- Returns structure with sign and magnitude code

**Step 4: BRC Tree Depth Selection**
```c
switch (BRCn) {
    case 0: BRCn=3;break; // BRC0: 3-level tree
    case 1: BRCn=4;break; // BRC1: 4-level tree  
    case 2: BRCn=6;break; // BRC2: 6-level tree
    case 3: BRCn=9;break; // BRC3: 9-level tree
    case 4: return(BRC4(p,cposition,bposition)); // BRC4: Special case
}
```
- Each BRC level uses different tree depth
- Higher compression = deeper trees = longer codes for rare values

**Step 5: Sign Bit Extraction**
```c
sign=next_bit(p,cposition,bposition);
if (sign==0) sol.sign=1; else sol.sign=-1;
```
- First bit always indicates sign (0=positive, 1=negative)

**Step 6: Tree Traversal Loop**
```c
hcode=0;
do {
    b=next_bit(p,cposition,bposition);
    if (b==0)                                    // 0 bit = leaf node
    {
        sol.mcode=hcode;return(sol);             // Return magnitude code
    }
    else 
    {
        hcode++;                                 // 1 bit = go deeper
        if (hcode==BRCn)                         // Max depth reached
        {
            sol.mcode=hcode;return(sol);
        }
    }
} while (hcode<BRCn);
```
- Traverses binary tree following bit pattern
- 0 bit = stop here, use current `hcode` as magnitude
- 1 bit = continue deeper into tree
- Longer bit patterns = larger magnitude values

### Main Packet Decode Function

**Step 7: Function Setup**
```c
int packet_decode(unsigned char *p,int NQ,float *IE, float *IO, float *QE, float *QO,char *brc,int *brcpos)
```
- Decodes all four channels of compressed radar data
- Also extracts compression parameters for quality assessment

**Step 8: Data Structure Initialization**
```c
static struct sh_code hcodeIE[52378];  // Huffman codes for each channel
static struct sh_code hcodeIO[52378];
static struct sh_code hcodeQE[52378];  
static struct sh_code hcodeQO[52378];
unsigned char BRCn[410];    // Compression levels (one per 128 samples)
unsigned char THIDXn[410];  // Threshold indices (for QE/QO channels)
```

### IE Channel Huffman Decoding

**Step 9: IE Channel BRC Processing**
```c
BRCindex=0;
hcode_index=0;
do
{
    BRCn[BRCindex]=next_bit(p,&cposition,&bposition)*4;  // MSB of 3-bit BRC
    BRCn[BRCindex]+=next_bit(p,&cposition,&bposition)*2; // Middle bit
    BRCn[BRCindex]+=next_bit(p,&cposition,&bposition)*1; // LSB
```
- Extracts 3-bit compression level for next 128 samples
- Builds BRC value bit by bit

**Step 10: IE Sample Decoding Loop**
```c
if ((hcode_index+128)>NQ) inc=(NQ-hcode_index);      // Handle partial blocks
for (h=0;h<inc;h++) // Process up to 128 samples
{
    hcodeIE[hcode_index]=BRC(BRCn[BRCindex],p,&cposition,&bposition);
    hcode_index++;
}
BRCindex++;
```
- Decodes 128 samples using same BRC level
- Adjusts for final partial block if `NQ` not multiple of 128
- Each sample becomes a `sh_code` structure with sign and magnitude

### IO Channel Processing

**Step 11: IO Channel Alignment**
```c
if (bposition!=7) {bposition=7;cposition++;} // Byte align
if ((cposition & 1)!=0) {cposition++;}       // Word align
```
- Ensures IO data starts on byte boundary
- Forces even byte address for proper alignment

**Step 12: IO Channel Decoding**
```c
BRCindex=0;
hcode_index=0;
do
{
    for (h=0;h<inc;h++)
    {
        hcodeIO[hcode_index]=BRC(BRCn[BRCindex],p,&cposition,&bposition);
        hcode_index++;
    }
    BRCindex++;
}
while (hcode_index<NQ);
```
- **Reuses same BRC values** from IE channel processing
- Decodes IO samples with identical block structure

### QE Channel Processing

**Step 13: QE Channel Alignment and THIDX**
```c
if (bposition!=7) {bposition=7;cposition++;} // Byte align
if ((cposition & 1)!=0) {cposition++;}       // Word align
BRCindex=0;
hcode_index=0;
do
{
    THIDXn[BRCindex]=get_THIDX(p,&cposition,&bposition); // 8-bit threshold
```
- QE channel includes threshold indices for reconstruction scaling
- One THIDX per 128-sample block

**Step 14: QE Sample Decoding**
```c
for (h=0;h<inc;h++)
{
    hcodeQE[hcode_index]=BRC(BRCn[BRCindex],p,&cposition,&bposition);
    hcode_index++;
}
```
- Uses same BRC values but adds THIDX information

### QO Channel Processing

**Step 15: QO Channel Decoding**
```c
// Same alignment and decoding as QE, but reuses THIDXn values
for (h=0;h<inc;h++)
{
    hcodeQO[hcode_index]=BRC(BRCn[BRCindex],p,&cposition,&bposition);
    hcode_index++;
}
```
- **Reuses THIDX values** from QE channel
- Final compressed data channel

### Reconstruction Phase

**Step 16: Reconstruction Calls**
```c
reconstruction(BRCn,THIDXn,hcodeIE,NQ,IE);
reconstruction(BRCn,THIDXn,hcodeIO,NQ,IO);
reconstruction(BRCn,THIDXn,hcodeQE,NQ,QE);
reconstruction(BRCn,THIDXn,hcodeQO,NQ,QO);
```
- Converts Huffman codes to actual floating-point values
- Uses lookup tables and scaling factors

---

## Reconstruction Process (reconstruct.c)

This function converts Huffman magnitude codes back to radar amplitude values.

### Lookup Table Definitions

**Step 1: BRC Lookup Tables**
```c
float BRC0[4]={3.,3.,3.16,3.53};         // Low compression values
float BRC1[4]={4.,4.,4.08,4.37};
float BRC2[6]={6.,6.,6.,6.15, 6.5,6.88};
float BRC3[7]={9.,9.,9.,9.,9.36,9.50, 10.1};
float BRC4[9]={15.,15.,15.,15.,15.,15., 15.22, 15.50, 16.05}; // High compression
```
- Each BRC level has different reconstruction values
- Higher BRC = larger baseline values = more quantization noise

**Step 2: Normalized Reconstruction Levels**
```c
float NRL0[4]={.3637,1.0915,1.8208,2.6406};     // BRC0 normalized levels
float NRL1[5]={.3042,.9127,1.5216,2.1313,2.8426}; // BRC1 normalized levels
// ... continuing for NRL2, NRL3, NRL4
```
- Used when THIDX values are high
- Provides finer quantization control

**Step 3: Scaling Factor Table**
```c
float SF[256] = {0., 0.630, 1.250, 1.880, 2.510, 3.130, ...};
```
- 256 scaling factors indexed by THIDX value
- Allows dynamic range adjustment

### Main Reconstruction Function

**Step 4: Function Entry**
```c
void reconstruction(unsigned char *BRCn,unsigned char *THIDXn,struct sh_code *hcode,int NQ,float *result)
```
- `BRCn`: Array of compression levels
- `THIDXn`: Array of threshold indices  
- `hcode`: Array of decoded Huffman codes
- `result`: Output array for reconstructed values

**Step 5: Processing Loop Setup**
```c
int hcode_index=0,h;
int BRCindex=0;
int inc=128;
do
{
    if ((hcode_index+128)>NQ) inc=(NQ-hcode_index); // Handle partial blocks
```
- Processes samples in blocks of 128
- Adjusts for final partial block

### Reconstruction Logic Per BRC Level

**Step 6: BRC0 Reconstruction**
```c
case 0: 
    if (THIDXn[BRCindex]<=3) 
    {
        if (hcode[hcode_index].mcode<3)
            result[hcode_index]=(float)(hcode[hcode_index].sign*hcode[hcode_index].mcode);
        else
            result[hcode_index]=(float)(hcode[hcode_index].sign)*BRC0[THIDXn[BRCindex]];
    }
    else  
        result[hcode_index]=(float)(hcode[hcode_index].sign)*NRL0[hcode[hcode_index].mcode]*SF[THIDXn[BRCindex]];
```
- **Low THIDX (≤3)**: Direct magnitude mapping or BRC table lookup
- **High THIDX (>3)**: Use normalized levels × scaling factor
- **Final value**: `sign × magnitude × scale`

**Step 7: BRC1 Reconstruction**
```c
case 1: 
    if (THIDXn[BRCindex]<=3) 
    {
        if (hcode[hcode_index].mcode<4)  // Note: threshold is 4 for BRC1
            result[hcode_index]=(float)(hcode[hcode_index].sign*hcode[hcode_index].mcode);
        else
            result[hcode_index]=(float)(hcode[hcode_index].sign)*BRC1[THIDXn[BRCindex]];
    }
    else  
        result[hcode_index]=(float)(hcode[hcode_index].sign)*NRL1[hcode[hcode_index].mcode]*SF[THIDXn[BRCindex]];
```
- Similar logic but with BRC1-specific thresholds and tables

**Step 8: BRC2 Reconstruction**
```c
case 2: 
    if (THIDXn[BRCindex]<=5)  // Threshold is 5 for BRC2
    {
        if (hcode[hcode_index].mcode<6)  // Magnitude threshold is 6
            result[hcode_index]=(float)(hcode[hcode_index].sign*hcode[hcode_index].mcode);
        else
            result[hcode_index]=(float)(hcode[hcode_index].sign)*BRC2[THIDXn[BRCindex]];
    }
    else  
        result[hcode_index]=(float)(hcode[hcode_index].sign)*NRL2[hcode[hcode_index].mcode]*SF[THIDXn[BRCindex]];
```

**Step 9: BRC3 Reconstruction**
```c
case 3: 
    if (THIDXn[BRCindex]<=6)  // Threshold is 6 for BRC3
    {
        if (hcode[hcode_index].mcode<9)  // Magnitude threshold is 9
            result[hcode_index]=(float)(hcode[hcode_index].sign*hcode[hcode_index].mcode);
        else
            result[hcode_index]=(float)(hcode[hcode_index].sign)*BRC3[THIDXn[BRCindex]];
    }
    else  
        result[hcode_index]=(float)(hcode[hcode_index].sign)*NRL3[hcode[hcode_index].mcode]*SF[THIDXn[BRCindex]];
```

**Step 10: BRC4 Reconstruction**
```c
case 4: 
    if (THIDXn[BRCindex]<=8)  // Threshold is 8 for BRC4
    {
        if (hcode[hcode_index].mcode<15)  // Magnitude threshold is 15
            result[hcode_index]=(float)(hcode[hcode_index].sign*hcode[hcode_index].mcode);
        else
            result[hcode_index]=(float)(hcode[hcode_index].sign)*BRC4[THIDXn[BRCindex]];
    }
    else  
        result[hcode_index]=(float)(hcode[hcode_index].sign)*NRL4[hcode[hcode_index].mcode]*SF[THIDXn[BRCindex]];
```

**Step 11: Sample and Block Increment**
```c
    hcode_index++;     // Next sample
}
BRCindex++;            // Next 128-sample block
```

**Step 12: Loop Continuation**
```c
while (hcode_index<NQ);
```
- Continues until all NQ samples processed

---

## Data Structures and Supporting Elements

### Structure Definitions

**Step 1: Huffman Code Structure**
```c
struct sh_code {
    int sign;   // +1 or -1
    int mcode;  // Magnitude code from Huffman tree
};
```
- Keeps sign and magnitude separate
- Prevents loss of sign information when magnitude is zero

### Key Constants and Calculations

**Step 2: FDBAQ Algorithm Parameters**
- **128 samples per block**: Standard FDBAQ block size
- **5 BRC levels (0-4)**: Different compression ratios
- **256 THIDX values**: Dynamic range scaling
- **4 channels**: IE, IO, QE, QO for complex I/Q pairs

**Step 3: File Organization**
- **Primary files**: `resultSW##_T####_NQ####.bin` (I/Q data)
- **Secondary files**: `brcSW##_T####.bin` (compression info)
- **Binary format**: 32-bit IEEE floats, little-endian

## Summary of Complete Workflow

**Step 1**: Read Sentinel-1 packet headers to identify data type and parameters
**Step 2**: For calibration data → Use bypass processing (simple bit unpacking)
**Step 3**: For echo data → Use FDBAQ processing (Huffman + reconstruction)
**Step 4**: Extract I/Q samples into four separate channels
**Step 5**: Write results as binary float arrays for SAR image processing
**Step 6**: Preserve compression metadata for quality assessment

This system enables scientific analysis of radar data from space, supporting applications like Earth observation, ice monitoring, ocean surface analysis, and environmental change detection.