# Sequential Documentation: C++ Sentinel-1 SAR Data Processing System

This documentation follows the **actual execution order** - starting from the user entry point and tracing through each file as it's called during normal operation of this comprehensive C++ SAR processing system.

## Entry Point: Command-Line Interface (image_write_main.cpp)

### Main Function - Starting Point

**Step 1: Program Execution Start**
```cpp
int main(int argc, char* argv[])
{
    STRING_VEC_1D help_strings = {
        "burst [swath] [burst_num] [in_path] [out_path]",
        "swath [swath] [in_path] [out_path]",
        "range_compressed_burst [swath] [burst_num] [in_path] [out_path]",
        // ... more command options
    };
```
- **User entry point**: When user runs the compiled executable
- **Help system setup**: Defines available commands and their syntax
- **Command-line interface**: Provides multiple processing options

**Step 2: Command Validation and Parsing**
```cpp
if(argv[1] == __null) 
{
    std::cout << "Please enter a command:" << std::endl;
    print_help(help_strings);  // ← CALLS cli.cpp
    return 1;
}

std::string command = std::string(argv[1]);
```
- **Input validation**: Ensures user provided a command
- **Command extraction**: Gets the requested operation from command line

**Step 3: Option Parsing Setup**
```cpp
std::unordered_map<std::string, bool> options = {
    {"--norm",     false},
    {"--norm_log", false},
    {"--mag",      false},
    {"--real",     false},
    {"--imag",     false}
};
options = parse_options(options, argv, 2);  // ← CALLS cli.cpp
```
- **Scaling options**: Sets up image scaling/visualization options
- **Option parsing**: Processes command-line flags for output format

**Step 4: Command Dispatch**
```cpp
if      (command == "burst")                    burst_command(&(argv[0]), options);
else if (command == "swath")                    swath_command(&(argv[0]), options);
else if (command == "range_compressed_burst")   range_compressed_burst_command(&(argv[0]), options);
// ... more command handlers
```
- **Command routing**: Dispatches to appropriate processing function
- **Parameter passing**: Forwards command-line arguments and options

---

## Command-Line Interface Support (cli.cpp)

### CLI Helper Functions - Second File Called

**Step 5: Help System**
```cpp
void print_help(const STRING_VEC_1D& help_strings)
{
    for (std::string help_string : help_strings)
    {
        std::cout << help_string << std::endl;
    }
}
```
- **Called by main**: When user needs help or provides invalid input
- **Usage display**: Shows available commands and syntax

**Step 6: Option Parsing**
```cpp
std::unordered_map<std::string, bool> parse_options(
    const std::unordered_map<std::string, bool>& options,
          char* args[],
    const int&  arg_index
) {
    std::unordered_map<std::string, bool> selections = options;
    
    int index = arg_index;
    while(args[index] != __null)
    {
        std::string users_option = std::string(args[index]);
        if (selections.contains(users_option))
        {
            selections[users_option] = !selections[users_option];  // Toggle option
        }
        index += 1;
    }
    return selections;
}
```
- **Called by main**: Processes command-line flags
- **Flag toggling**: Enables/disables visualization options
- **Safe parsing**: Validates options exist before setting

**Step 7: Argument Validation**
```cpp
void validate_args(
    const std::string&   command,
    const STRING_VEC_1D& command_args,
    const STRING_VEC_1D& arg_types,
          char*          args[],
    const int&           start_index
) {
    int end_index = command_args.size() + start_index;
    for (int i = start_index; i < end_index; i++)
    {
        if (args[i] == __null)
        {
            std::cout << command  << " is missing the following argument: "
                 << command_args[index] << std::endl;
            exit(1);
        }
        // Type validation logic...
    }
}
```
- **Called by command handlers**: Validates required arguments are present
- **Type checking**: Ensures arguments match expected types (int, string, path)
- **File validation**: Checks that file paths are accessible

---

## Image Writing Interface (image_write.cpp)

### Command Handler Functions - Third File Called

**Step 8: Burst Command Handler**
```cpp
void burst_command(char *argv[], std::unordered_map<std::string, bool>& options)
{
    STRING_VEC_1D args  = {"swath", "burst_num", "in_path", "out_path"};
    STRING_VEC_1D types = {"string", "int", "path", "string"};
    validate_args("burst", args, types, argv);  // ← CALLS cli.cpp

    std::string swath    = std::string(argv[2]);
    int burst_num        = std::stoi(argv[3]);
    std::string in_path  = std::string(argv[4]);
    std::string out_path = std::string(argv[5]);
    std::string scaling  = parse_scaling_mode(options);  // ← CALLS cli.cpp

    write_burst(in_path, out_path, swath, burst_num, scaling);  // ← CALLS image_write.cpp
}
```
- **Called by main**: When user requests single burst processing
- **Parameter extraction**: Gets swath, burst number, file paths
- **Validation**: Ensures all required arguments are present and valid
- **Processing dispatch**: Calls specific burst writing function

**Step 9: Burst Writing Function**
```cpp
void write_burst(
    const std::string& in_filename,
    const std::string& out_filename,
    const std::string& swath_name,
    const int&         burst_num,
    const std::string& scaling_mode
) {
    S1_Decoder s1(in_filename);  // ← CALLS s1_decoder.cpp

    CF_VEC_2D burst = s1.get_burst(swath_name, burst_num);  // ← CALLS s1_decoder.cpp

    write_tif(burst, out_filename, scaling_mode);  // ← CALLS local function
}
```
- **Called by command handler**: Processes single burst to TIFF image
- **S1_Decoder creation**: Initializes main processing class
- **Data extraction**: Gets processed burst data
- **Image writing**: Converts to TIFF format

**Step 10: TIFF Writing Function**
```cpp
void write_tif(
    CF_VEC_2D& img_data,
    const std::string& out_filename,
    const std::string& scaling_mode
) {
    int rows = img_data.size();
    int cols = img_data[0].size();

    std::vector<float> scaled = scale(img_data, scaling_mode);  // ← CALLS signal_processing.cpp

    _write_tif(scaled, rows, cols, out_filename);  // ← CALLS local function
}
```
- **Scaling application**: Converts complex data to displayable format
- **TIFF creation**: Writes formatted image data to file

---

## High-Level Decoder Interface (s1_decoder.cpp)

### S1_Decoder Class - Fourth File Called

**Step 11: S1_Decoder Constructor**
```cpp
S1_Decoder(const std::string& filename) 
{
    _filename = filename;
    _set_packets();      // ← CALLS local method
    _set_state_vectors(); // ← CALLS local method
}
```
- **Called by image_write functions**: Main processing class initialization
- **File storage**: Preserves input filename
- **Packet processing**: Reads and organizes all packets from file
- **State vector setup**: Extracts satellite ephemeris data

**Step 12: Packet Organization**
```cpp
void S1_Decoder::_set_packets()
{
    _flat_packets = L0Packet::get_packets(_filename, 0);  // ← CALLS packet.cpp

    for (L0Packet packet : _flat_packets) 
    {
        _swath_counts[packet.get_swath()]++;  // ← CALLS packet.cpp
    }

    for (std::pair<std::string, int> swath_count : _swath_counts)
    {
        std::string name = swath_count.first;
        if (ECHO_SWATHS.contains(name))  // ← USES structs.h
        {
            _echo_packets[name] = L0Packet::get_packets_in_bursts(_flat_packets, name);  // ← CALLS packet.cpp
        }
        else if (CAL_SWATHS.contains(name))  // ← USES structs.h
        {
            _cal_packets[name] = L0Packet::get_packets_in_bursts(_flat_packets, name, true);  // ← CALLS packet.cpp
        }
    }
}
```
- **Packet reading**: Reads all packets from input file
- **Swath organization**: Groups packets by radar swath (beam)
- **Burst detection**: Identifies individual radar acquisitions
- **Data categorization**: Separates echo data from calibration data

**Step 13: Burst Data Retrieval**
```cpp
CF_VEC_2D S1_Decoder::get_burst(
    const std::string& swath,
    const int& burst
) {
    _validate_request(swath, burst);  // ← CALLS local method
    
    PACKET_VEC_1D burst_packets = _echo_packets[swath][burst];

    int num_packets = burst_packets.size();
    int num_samples = 2 * burst_packets[0].get_num_quads();  // ← CALLS packet.cpp

    CF_VEC_2D signals(num_packets, CF_VEC_1D(num_samples));

    #pragma omp parallel for 
    for (int i = 0; i < num_packets; i++)
    {
        L0Packet packet = burst_packets[i];
        signals[i] = packet.get_signal();  // ← CALLS packet.cpp
    }

    return signals;
}
```
- **Called by image_write functions**: Extracts specific burst data
- **Request validation**: Ensures requested swath and burst exist
- **Parallel processing**: Uses OpenMP for multi-threaded packet decoding
- **Signal extraction**: Gets I/Q samples from each packet

---

## Core Packet Management (packet.cpp)

### L0Packet Class - Fifth File Called

**Step 14: Static Packet Reading**
```cpp
PACKET_VEC_1D L0Packet::get_packets(const std::string& filename, const int& num_packets)
{
    std::ifstream data = open_file(filename);  // ← CALLS decoding_utils.cpp
    return get_packets(data, num_packets);  // ← CALLS local method
}
```
- **Called by S1_Decoder**: Reads packets from file
- **File opening**: Opens binary SAR data file
- **Stream processing**: Delegates to stream-based packet reading

**Step 15: Stream-Based Packet Reading**
```cpp
PACKET_VEC_1D L0Packet::get_packets(std::ifstream& data, const int& num_packets)
{
    PACKET_VEC_1D packets;

    int index = 0;
    bool get_all_packets = num_packets == 0;

    while (!data.eof() and (index < num_packets or get_all_packets))
    {
        try
        {
            L0Packet packet = L0Packet::get_next_packet(data, index);  // ← CALLS local method

            if (!packet.is_empty()) packets.push_back(packet);
            else break;
            index += 1;
        }
        catch(std::runtime_error)
        {
            std::cout << "Caught a runtime error while decoding packet #"
                 << index << ". Skipping..." << std::endl;
            continue;
        }
    }
    return packets;
}
```
- **Sequential reading**: Processes file packet by packet
- **Error handling**: Skips corrupted packets and continues
- **Flexible count**: Can read all packets or specific number

**Step 16: Single Packet Processing**
```cpp
L0Packet L0Packet::get_next_packet(std::ifstream& data, int& packet_index)
{
    UINT8_VEC_1D primary_bytes = read_bytes(data, 6);  // ← CALLS decoding_utils.cpp
    std::unordered_map<std::string, int> primary_header = _parse_header(
        primary_bytes,
        PRIMARY_HEADER,        // ← USES structs.h
        PRIMARY_HEADER_FIELDS  // ← USES structs.h
    );

    UINT8_VEC_1D secondary_bytes = read_bytes(data, 62);  // ← CALLS decoding_utils.cpp
    std::unordered_map<std::string, int> secondary_header = _parse_header(
        secondary_bytes,
        SECONDARY_HEADER,        // ← USES structs.h
        SECONDARY_HEADER_FIELDS  // ← USES structs.h
    );

    u_int32_t packet_length    = primary_header["packet_data_length"];
    u_int32_t user_data_length = packet_length + 1 - SECONDARY_HEADER_SIZE;

    UINT8_VEC_1D user_data = read_bytes(data, user_data_length);  // ← CALLS decoding_utils.cpp

    L0Packet packet = L0Packet(
        primary_header,
        secondary_header,
        user_data,
        packet_index
    );
    return packet;
}
```
- **Header parsing**: Extracts primary and secondary headers
- **Variable-length reading**: Payload size determined from header
- **Packet construction**: Creates L0Packet object with parsed data

**Step 17: L0Packet Constructor**
```cpp
L0Packet(
    std::unordered_map<std::string, int> primary_header,
    std::unordered_map<std::string, int> secondary_header,
    UINT8_VEC_1D raw_user_data,
    int packet_index
) {
    _primary_header   = primary_header;
    _secondary_header = secondary_header;
    _raw_user_data    = raw_user_data;

    _packet_index     = packet_index;
    _num_quads        = secondary_header["num_quadratures"];
    _test_mode        = secondary_header["test_mode"];
    _baq_mode         = secondary_header["baq_mode"];
    _user_data_length = primary_header["packet_data_length"] + 1 - SECONDARY_HEADER_SIZE;
    _num_baq_blocks   = ceil((2.0 * double(_num_quads)) / 256.0);

    _set_data_format();  // ← CALLS local method

    _is_empty = false;
}
```
- **Data storage**: Preserves headers and payload
- **Parameter extraction**: Gets key decoding parameters
- **Format determination**: Identifies compression type (A, B, C, or D)
- **Block calculation**: Determines number of compression blocks

### Signal Extraction Process

**Step 18: Signal Retrieval (Lazy Loading)**
```cpp
CF_VEC_1D L0Packet::get_signal()
{
    if (!_signal_set_flag)
    {
        _set_signal();  // ← CALLS local method
    }
    return _signal;
}
```
- **Called by S1_Decoder**: Extracts I/Q samples from packet
- **Lazy evaluation**: Only decodes when first requested
- **Caching**: Stores decoded result for subsequent calls

**Step 19: Signal Decoding Dispatch**
```cpp
void L0Packet::_set_signal()
{
    _signal.reserve(_num_quads*4);
    _decode();  // ← CALLS local method
    _signal_set_flag = true;

    UINT8_VEC_1D().swap(_raw_user_data);  // Free raw data memory
}
```
- **Memory allocation**: Reserves space for decoded samples
- **Decoding dispatch**: Calls appropriate decoder based on data format
- **Memory management**: Frees raw data after decoding

**Step 20: Format-Specific Decoding**
```cpp
void L0Packet::_decode() 
{
    int bit_index = 0;

    if (_data_format == 'A' || _data_format == 'B') 
    {
        // Bypass/Calibration data processing
        H_CODE IE, IO, QE, QO;

        _set_quad_types_a_and_b(IE, bit_index);  // ← CALLS local method
        _set_quad_types_a_and_b(IO, bit_index);
        _set_quad_types_a_and_b(QE, bit_index);
        _set_quad_types_a_and_b(QO, bit_index);

        _signal = _get_signal_types_a_and_b(IE, IO, QE, QO);  // ← CALLS local method
        return;
    }

    // FDBAQ compressed data processing
    QUAD IE = QUAD("IE", _num_baq_blocks);
    QUAD IO = QUAD("IO", _num_baq_blocks);
    QUAD QE = QUAD("QE", _num_baq_blocks);
    QUAD QO = QUAD("QO", _num_baq_blocks);

    if (_data_format == 'D')
    {
        _brc.resize(_num_baq_blocks);
        _thresholds.resize(_num_baq_blocks);

        _set_quad_type_d(IE, bit_index);  // ← CALLS local method with Huffman decoding
        _set_quad_type_d(IO, bit_index);
        _set_quad_type_d(QE, bit_index);
        _set_quad_type_d(QO, bit_index);

        _signal = _get_signal_type_d(IE, IO, QE, QO);  // ← CALLS local method
    }
}
```
- **Format detection**: Routes to appropriate decoder
- **Type A/B**: Uncompressed 10-bit samples (calibration)
- **Type D**: FDBAQ compressed samples (echo data)
- **Four channels**: IE, IO, QE, QO extracted separately

### FDBAQ Decoding Process (Type D)

**Step 21: Type D Quad Decoding**
```cpp
void L0Packet::_set_quad_type_d(QUAD& component, int& bit_index)
{
    u_int8_t brc;
    u_int16_t threshold;

    int brc_bits       = 3;
    int threshold_bits = 8;       

    for (int i = 0; i < _num_baq_blocks; i++)
    {
        bool is_ie = (component.key == "IE");
        bool is_qe = (component.key == "QE");
        bool is_last_block = (i == _num_baq_blocks - 1);
        
        if (is_ie)
        {
            brc = read_n_bits(_raw_user_data, bit_index, brc_bits);  // ← CALLS decoding_utils.cpp
            _brc[i] = brc;
            bit_index += brc_bits;
        }
        else if (is_qe)
        {
            threshold = read_n_bits(_raw_user_data, bit_index, threshold_bits);  // ← CALLS decoding_utils.cpp
            _thresholds[i] = threshold;
            bit_index += threshold_bits;
        }
        
        brc = _brc[i];
        component.blocks[i] = _get_h_code_type_d(brc, bit_index, is_last_block);  // ← CALLS local method
    }
    bit_index = _get_next_word_boundary(bit_index);
}
```
- **Block-based processing**: Processes 128 samples per block
- **Parameter extraction**: BRC from IE channel, THIDX from QE channel
- **Parameter sharing**: All channels use same BRC and THIDX per block
- **Huffman decoding**: Extracts variable-length codes

**Step 22: Huffman Code Extraction**
```cpp
H_CODE L0Packet::_get_h_code_type_d(
    const u_int8_t& brc,
          int&      bit_index,
    const bool&     is_last_block
) {
    int num_codes = is_last_block ? _num_quads - (128 * (_num_baq_blocks - 1)) : 128;

    H_CODE h_code(num_codes);

    for (int i = 0; i < num_codes; i++)
    {
        int sign   = read_n_bits(_raw_user_data, bit_index, 1);  // ← CALLS decoding_utils.cpp
        bit_index += 1;

        u_int16_t m_code = huffman_decode(_raw_user_data, brc, bit_index);  // ← CALLS decoding_utils.cpp

        h_code.signs[i] = sign;
        h_code.m_codes[i] = m_code;
    }
    return h_code;
}
```
- **Sign extraction**: First bit is always sign
- **Huffman decoding**: Variable-length magnitude codes
- **Boundary handling**: Final block may have fewer than 128 samples

**Step 23: Value Reconstruction**
```cpp
double L0Packet::_get_s_values_type_d(
    const u_int8_t& brc,
    const u_int16_t& threshold_index,
    const int& sign,
    const int& m_code
) {
    if (threshold_index <= BRC_TO_THIDX[brc])  // ← USES structs.h
    {
        int flag = BRC_TO_M_CODE[brc];  // ← USES structs.h

        if      (m_code <  flag) return pow(-1.0, sign) * m_code;
        else if (m_code == flag) return pow(-1.0, sign) * SIMPLE_RECONSTRUCTION[1][brc][threshold_index];  // ← USES structs.h
        else throw std::runtime_error("MCode is greater than the comparison flag.");
    }
    return pow(-1.0, sign) * NORMALIZED_RECONSTRUCTION[1][brc][m_code] * THIDX_TO_SF[threshold_index];  // ← USES structs.h
}
```
- **Threshold-based reconstruction**: Different methods for low/high thresholds
- **Direct mapping**: Small magnitude codes map to integer values
- **Table lookup**: Larger codes use reconstruction tables
- **Scaling**: High thresholds use scaling factors

---

## Low-Level Decoding Utilities (decoding_utils.cpp)

### Binary Data Processing - Sixth File Called

**Step 24: File Opening**
```cpp
std::ifstream open_file(const std::string& filename)
{
    std::ifstream data(filename, std::ios::binary);
    if (!data.is_open()) 
    {
        throw std::runtime_error("Unable to open: " + filename);
    }
    return data;
}
```
- **Called by packet.cpp**: Opens SAR data files for reading
- **Binary mode**: Ensures proper handling of binary data
- **Error handling**: Throws exception if file cannot be opened

**Step 25: Byte Reading**
```cpp
UINT8_VEC_1D read_bytes(
    std::ifstream&  data,
    const int& num_bytes
) {
    UINT8_VEC_1D buffer(num_bytes);
    data.read(
        reinterpret_cast<char*>(buffer.data()),
        num_bytes
    );
    return buffer;
}
```
- **Called by packet.cpp**: Reads exact number of bytes
- **Buffer allocation**: Creates vector of requested size
- **Pointer casting**: Converts vector data pointer for stream reading

**Step 26: Bit Field Extraction**
```cpp
u_int64_t read_n_bits(
    const UINT8_VEC_1D& data,
    const int& start_bit,
    const int& n
) {
    if (n < 1 || n > 64) 
    {
        throw std::invalid_argument("Invalid number of bits to read. Must be between 1 and 64.");
    }
    
    int byte_index = start_bit / 8;
    int bit_offset = start_bit % 8;

    u_int64_t result = 0;
    int bits_read = 0;

    while (bits_read < n) 
    {
        int bits_left_in_byte = 8 - bit_offset;
        int bits_to_read = std::min(bits_left_in_byte, n - bits_read);

        u_int8_t mask = (1 << bits_to_read) - 1;
        u_int8_t shifted_data = (data[byte_index] >> (bits_left_in_byte - bits_to_read)) & mask;

        result = (result << bits_to_read) | shifted_data;

        bits_read += bits_to_read;
        bit_offset = 0;
        byte_index++;
    }
    return result;
}
```
- **Called by packet.cpp**: Extracts bit fields from byte arrays
- **Arbitrary positioning**: Can start at any bit position
- **Boundary handling**: Spans multiple bytes as needed
- **Bit manipulation**: Uses masks and shifts for precise extraction

**Step 27: Huffman Decoding**
```cpp
u_int16_t huffman_decode(
    const UINT8_VEC_1D& data,   
    const int& brc, 
          int& bit_index
) {
    u_int16_t bits     = -1;
    u_int8_t  bit_len  = BRC_TO_HUFFMAN_START_BIT_LEN[brc];  // ← USES structs.h
    u_int8_t  max_bits = 10;

    if (brc == 4)
    {
        if (read_n_bits(data, bit_index, bit_len) == 0)
        {
            bit_index += 2;
            return 0;
        }
        bit_len += 1;
    }
    
    for (int i = 0; i < max_bits; i++)
    {
        bits = read_n_bits(data, bit_index, bit_len);

        if (!HUFFMAN_CODINGS[brc].contains(bits)) bit_len += 1;  // ← USES structs.h
        else break;

        if (bit_len > 10) 
        {
            throw std::out_of_range("Max bit length exceeded in Huffman decoding.");
        }
    }
    bit_index += bit_len;

    return HUFFMAN_CODINGS[brc].at(bits);  // ← USES structs.h
}
```
- **Called by packet.cpp**: Decodes variable-length Huffman codes
- **BRC-specific trees**: Different compression levels use different trees
- **Progressive reading**: Starts with minimum bits, extends as needed
- **Tree traversal**: Uses lookup tables for code-to-value mapping

---

## Data Structure Definitions (structs.h)

### Constants and Lookup Tables - Used Throughout

**Step 28: Physical Constants**
```cpp
const std::complex<double> I(0.0, 1.0); 

const double PI             = 3.14159265358979;
const double SPEED_OF_LIGHT = 299792458.0;
const double CENTER_FREQ = 5.405000454334350e+9;
const double WAVELENGTH = SPEED_OF_LIGHT / CENTER_FREQ;
const double F_REF = 37.53472224;
```
- **Referenced throughout**: Physical constants for radar calculations
- **Complex unit**: Imaginary unit for complex number operations
- **Radar parameters**: Sentinel-1 specific operating characteristics

**Step 29: Header Structure Definitions**
```cpp
// Table 2.4-1 from Page 13
const INT_VEC_1D PRIMARY_HEADER = {
    3,   // Packet Version Number
    1,   // Packet Type
    1,   // Secondary Header Flag
    7,   // Process ID
    4,   // Process Category
    2,   // Sequence Flags
    14,  // Packet Sequence Count 
    16   // Packet Data Length
};

const STRING_VEC_1D PRIMARY_HEADER_FIELDS = {
    "packet_version_number",
    "packet_type",
    "secondary_header_flag",
    // ... continuing for all fields
};
```
- **Used by packet.cpp**: Defines header parsing structure
- **Bit field lengths**: Specifies exact bit counts for each field
- **Field naming**: Provides consistent field names

**Step 30: Huffman Coding Tables**
```cpp
const std::vector<std::unordered_map<u_int16_t, u_int8_t>> HUFFMAN_CODINGS = {
    {
        {0, 0},
        {2, 1},
        {6, 2},
        {7, 3}
    },
    // ... continuing for BRC levels 1-4
};
```
- **Used by decoding_utils.cpp**: Huffman tree lookup tables
- **BRC-specific**: Different compression levels have different trees
- **Bit pattern mapping**: Maps bit patterns to magnitude codes

**Step 31: Reconstruction Tables**
```cpp
const std::vector<D_VEC_2D> SIMPLE_RECONSTRUCTION = {
    {   // Values for BAQ Compressed Data
        { 3.0000,  3.0000,  3.1200,  3.5500, /* ... */ },
        { 7.0000,  7.0000,  7.0000,  7.1700, /* ... */ },
        // ... continuing
    },  
    {   // Values for FDBAQ Compressed Data
        { 3.0000,  3.0000,  3.1600,  3.5300, /* ... */ },
        // ... continuing
    }
};

const D_VEC_1D THIDX_TO_SF = {
      0.00,   0.63,   1.25,   1.88,   2.51,   3.13, /* ... 256 entries */
};
```
- **Used by packet.cpp**: Value reconstruction lookup tables
- **Compression-specific**: Different tables for different algorithms
- **Scaling factors**: 256 scaling values indexed by THIDX

---

## Advanced Processing: Range and Azimuth Compression

### Range Compression Processing

**Step 32: Range Compression (when requested)**
```cpp
CF_VEC_2D S1_Decoder::get_range_compressed_burst(
    const std::string& swath,
    const int& burst,
    const bool& range_doppler
) {
    _validate_request(swath, burst);

    PACKET_VEC_1D burst_packets = _echo_packets[swath][burst];

    return _range_compress(burst_packets, true, range_doppler);  // ← CALLS local method
}
```
- **Called by image_write functions**: When user requests range-compressed data
- **Processing option**: Can include Doppler domain processing

**Step 33: Range Compression Implementation**
```cpp
CF_VEC_2D S1_Decoder::_range_compress(
    PACKET_VEC_1D& packets,
    const bool& do_ifft,
    const bool& do_azimuth_fft
) {
    L0Packet first_packet = packets[0];

    // Read complex data from all packets
    CF_VEC_2D range_compressed(num_packets, CF_VEC_1D(num_samples));

    #pragma omp parallel for
    for (int i = 0; i < num_packets; i++)
    {
        L0Packet packet = packets[i];
        CF_VEC_1D signal = packet.get_signal();  // ← CALLS packet.cpp
        range_compressed[i] = signal;
    }

    // Convert to frequency domain
    compute_axis_dft_in_place(range_compressed, 0, 1, false);  // ← CALLS signal_processing.cpp

    // Apply matched filter
    CF_VEC_1D reference_function = get_reference_function(packets[0].get_replica_chirp());  // ← CALLS image_formation.cpp
    
    for (int i = 0; i < num_packets; i++)
    {
        range_compressed[i] = pulse_compression(range_compressed[i], reference_function);  // ← CALLS image_formation.cpp
    }

    // Convert back to time domain
    if (do_ifft)
    {
        compute_axis_dft_in_place(range_compressed, 0, 1, true);  // ← CALLS signal_processing.cpp
    }

    return range_compressed;
}
```
- **Parallel signal extraction**: Multi-threaded packet processing
- **Frequency domain processing**: FFT for matched filtering
- **Pulse compression**: Correlates with reference chirp
- **Domain conversion**: Flexible time/frequency domain output

---

## Signal Processing Library (signal_processing.cpp)

### DSP Functions - Seventh File Called

**Step 34: FFT Processing**
```cpp
void compute_axis_dft_in_place(
    CF_VEC_2D&  signals,
          int   fft_size = 0,
    const int&  axis     = 0,
    const bool& inverse  = false
) {
    if (fft_size == 0)
    {
        fft_size = axis ? signals[0].size() : signals.size();
    }
    
    if (not axis)
    {
        signals = transpose(signals);
        _compute_axis_dft(signals, fft_size, inverse);
        signals = transpose(signals);
    }
    else
    {
        _compute_axis_dft(signals, fft_size, inverse);
    }
}
```
- **Called by s1_decoder.cpp**: Performs FFTs on 2D signal arrays
- **Axis selection**: Can operate on rows (axis=0) or columns (axis=1)
- **In-place operation**: Modifies data directly for memory efficiency

**Step 35: Core FFT Implementation**
```cpp
void _compute_axis_dft(
    CF_VEC_2D&  signals,
          int&  fft_size,
    const bool& inverse
) {
    int signal_rows   = signals.size();
    int fft_direction = inverse ? FFTW_BACKWARD : FFTW_FORWARD;

    std::vector<fftw_plan> plans(signal_rows);

    std::transform(
        signals.begin(), signals.end(),
            plans.begin(),
                [fft_size, fft_direction] (CF_VEC_1D& row) {
                    return fftw_plan_dft_1d(
                        fft_size,
                        reinterpret_cast<fftw_complex*>(row.data()),
                        reinterpret_cast<fftw_complex*>(row.data()),
                        fft_direction,
                        FFTW_ESTIMATE
                    );
                }
    );

    #pragma omp parallel for
    for (int i = 0; i < signal_rows; i++)
    {
        fftw_execute(plans[i]);
    }

    // Cleanup and normalization...
}
```
- **FFTW integration**: Uses optimized FFTW library
- **Plan creation**: Pre-computes FFT plans for efficiency
- **Parallel execution**: Multi-threaded FFT computation
- **Memory management**: Properly destroys plans after use

**Step 36: Data Scaling and Conversion**
```cpp
std::vector<float> scale(const CF_VEC_2D& signal, const std::string& scaling_mode)
{
    int rows = signal.size();
    int cols = signal[0].size();

    std::vector<float> samples(rows*cols);

    if      (scaling_mode == "norm_log") samples = flatten(norm_2d(signal, true));
    else if (scaling_mode == "norm"    ) samples = flatten(norm_2d(signal, false));
    else if (scaling_mode == "mag"     ) samples = flatten(magnitude_2d(signal));    
    else if (scaling_mode == "real" or scaling_mode == "imag")
    {
        bool real = scaling_mode == "real";
        
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                samples[i*cols+j] = real ? signal[i][j].real() : signal[i][j].imag();
            }
        }
    }

    return samples;
}
```
- **Called by image_write.cpp**: Converts complex data for visualization
- **Multiple scaling modes**: Magnitude, phase, logarithmic, linear
- **Data flattening**: Converts 2D array to linear array for image writing

---

## Image Formation Algorithms (image_formation.cpp)

### SAR Processing Functions - Eighth File Called

**Step 37: Reference Function Generation**
```cpp
CF_VEC_1D get_reference_function(const CF_VEC_1D& replica_chirp)
{
    int num_samples = replica_chirp.size();

    CF_VEC_1D reference = replica_chirp;

    F_VEC_1D norm = magnitude_1d(replica_chirp);  // ← CALLS signal_processing.cpp

    double norm_size = norm.size();
    std::for_each(
        norm.begin(), norm.end(),
            [norm_size](std::complex<double> n) { n *= n / norm_size; }
    );
    double energy = std::accumulate(norm.begin(), norm.end(), 0.0);

    compute_1d_dft_in_place(reference, 0, false);  // ← CALLS signal_processing.cpp
    conjugate_in_place(reference);  // ← CALLS signal_processing.cpp

    std::for_each(
         reference.begin(), reference.end(),
            [energy](std::complex<double> &n) { n /= energy; }
    );

    return reference;
}
```
- **Called by s1_decoder.cpp**: Creates matched filter for pulse compression
- **Energy normalization**: Normalizes reference function
- **Frequency domain**: Converts to frequency domain and conjugates
- **Matched filtering**: Prepares for correlation-based compression

**Step 38: Pulse Compression**
```cpp
CF_VEC_1D pulse_compression(
    const CF_VEC_1D& signal,
    const CF_VEC_1D& reference
) {
    int num_samples = signal.size();

    CF_VEC_1D signal_ = signal;

    std::transform(
        reference.begin(), reference.end(),
            signal_.begin(), signal_.begin(),
                [] (const std::complex<double>& n, std::complex<double>& r) { return n * r;}
    );

    return CF_VEC_1D(signal_.begin(), signal_.begin() + num_samples);
}
```
- **Called by s1_decoder.cpp**: Applies matched filter for range compression
- **Element-wise multiplication**: Frequency domain correlation
- **Range resolution**: Improves range resolution through pulse compression

### Advanced SAR Processing (when requested)

**Step 39: Azimuth Compression Processing**
```cpp
CF_VEC_2D S1_Decoder::_azimuth_compress(PACKET_VEC_1D& packets, const bool& tops_mode)
{
    // Range compression first
    CF_VEC_2D radar_data;
    if (tops_mode) radar_data = _range_compress(packets, true, false);
    else radar_data = _range_compress(packets, false, true);

    // Extract satellite parameters
    D_VEC_1D slant_ranges = packets[0].get_slant_ranges();
    F_VEC_1D v_0 = _state_vectors.velocities[0];
    double v_norm = std::sqrt(std::pow(v_0[0], 2.0) + std::pow(v_0[1], 2.0) + std::pow(v_0[2], 2.0));

    // Doppler processing
    if (tops_mode)
    {
        double dc_rate = get_doppler_centroid_rate(packets, v_norm);  // ← CALLS doppler.cpp
        F_VEC_1D doppler_centroid = get_doppler_centroid(
            radar_data, dc_rate, burst_length_seconds, first_packet  // ← CALLS doppler.cpp
        );
    }

    // Complex azimuth focusing algorithm...
    return radar_data;
}
```
- **Multi-stage processing**: Range compression followed by azimuth compression
- **Doppler analysis**: Calculates Doppler parameters for focusing
- **TOPS mode support**: Handles Terrain Observation by Progressive Scans

---

## Doppler Processing (doppler.cpp)

### Doppler Analysis Functions - Ninth File Called

**Step 40: Doppler Centroid Estimation**
```cpp
F_VEC_1D get_doppler_centroid(
    CF_VEC_2D& range_compressed,
    const double& doppler_centroid_rate,
    const double& burst_duration,
    L0Packet& first_packet,
    const int& num_rng_blocks
) {
    double prf = 1.0 / (first_packet.get_pri() * 1e-6);  // ← CALLS packet.cpp
    
    CF_VEC_2D precoditioned_burst = dce_preconditioning(range_compressed, doppler_centroid_rate, 1.06);
    F_VEC_1D  wrapped_estimates   = get_wrapped_estimates(precoditioned_burst, prf);
    
    // Block-based processing for different range positions
    F_VEC_1D  fine_dc_estimates(num_rng_blocks);
    for (int rng_block_index = 0; rng_block_index < num_rng_blocks; rng_block_index++)
    {
        // Average wrapped estimates within block
        double dc_sum = std::accumulate(rng_block.begin(), rng_block.end(), 0.0);
        fine_dc_estimates[rng_block_index] = dc_sum / (double(end_index) - double(start_index));
    }

    F_VEC_1D unwrapped_estimates = get_unwrapped_estimates(fine_dc_estimates, rng_times, prf, 8);
    
    return unwrapped_estimates;
}
```
- **Called by s1_decoder.cpp**: Estimates Doppler centroid for focusing
- **PRF calculation**: Gets pulse repetition frequency from packet
- **Preconditioning**: Applies de-ramping for better estimation
- **Block processing**: Estimates Doppler at different range positions
- **Phase unwrapping**: Resolves phase ambiguities

---

## Auxiliary Data Processing

### State Vector Processing (state_vectors.cpp)

**Step 41: State Vector Extraction**
```cpp
void STATE_VECTORS::parse_subcomm_dicts(SUBCOMM_DICTS subcomm_dicts)
{
    std::set<double> unique_times = {0.0};

    for (SUBCOMM_DICT_DOUBLE subcomm_dict : subcomm_dicts)
    {
        STATE_VECTOR state_vector(subcomm_dict);

        double current_time = state_vector.time;
        double previous_time = *unique_times.rbegin();
        bool is_valid_time = current_time > previous_time;

        if (is_valid_time)
        {
            unique_times.insert(current_time);
            times.push_back(state_vector.time);
            positions.push_back(state_vector.position);
            velocities.push_back(state_vector.velocity);
            quaternions.push_back(state_vector.quaternions);
            angular_rates.push_back(state_vector.angular_rate);
            attitudes.push_back(state_vector.attitude);
        }
    }
}
```
- **Called by s1_decoder.cpp**: Processes satellite ephemeris data
- **Time validation**: Ensures chronological ordering
- **Multi-parameter extraction**: Position, velocity, attitude
- **Data organization**: Maintains parallel arrays for interpolation

**Step 42: State Vector Interpolation**
```cpp
STATE_VECTOR STATE_VECTORS::interpolate(const double& time)
{    
    STATE_VECTOR state_vector;

    // Boundary condition handling
    if (time > times.back()) return get_last_state();
    if (time < times[0])     return get_first_state();

    // Find bounding time indices
    std::pair<D_VEC_1D::iterator, D_VEC_1D::iterator> time_bounds = 
        find_time_bounds(time, times.begin(), times.end());

    int a_index = time_bounds.first - times.begin();
    int b_index = time_bounds.second - times.begin();

    double a = *time_bounds.first;
    double b = *time_bounds.second;
    double t = (time - a) / (b - a);

    // Linear interpolation of all parameters
    state_vector.velocity = interpolate_vector(velocities, a_index, b_index, t);
    state_vector.position = interpolate_vector(positions, a_index, b_index, t);
    state_vector.quaternions = interpolate_vector(quaternions, a_index, b_index, t);
    // ...

    return state_vector;
}
```
- **Called by s1_decoder.cpp**: Provides satellite state at any time
- **Boundary handling**: Extrapolation for times outside data range
- **Binary search**: Efficient time boundary finding
- **Linear interpolation**: Smooth state estimation between data points

---

## Type Definitions and Data Structures (misc_types.h)

### Type System - Used Throughout

**Step 43: Fundamental Type Definitions**
```cpp
typedef std::uint8_t u_int8_t;
typedef std::uint16_t u_int16_t;
typedef std::uint32_t u_int32_t;
typedef std::uint64_t u_int64_t;

typedef struct std::vector<double>                    F_VEC_1D;
typedef struct std::vector<std::vector<double>>       F_VEC_2D;

typedef struct std::vector<std::complex<double>>              CF_VEC_1D;
typedef struct std::vector<std::vector<std::complex<double>>> CF_VEC_2D;
```
- **Used throughout**: Consistent type naming across all modules
- **Vector types**: 1D and 2D vectors for different data types
- **Complex support**: Complex number vectors for I/Q data

**Step 44: Specialized Structures**
```cpp
struct SIGNAL_PAIR {
    CF_VEC_2D signals;
    CF_VEC_2D replica_chirps;
};
```
- **Data containers**: Structured data for related signal components
- **Type safety**: Prevents mixing of different data types

---

## Auxiliary Data Decoders (aux_decoding.cpp)

### Index and Annotation Processing

**Step 45: Index Record Processing**
```cpp
VEC_UNSORTEDMAP index_decoder(std::ifstream& data)
{
    int record_size = 36;

    VEC_UNSORTEDMAP index_records;

    while (!data.eof())
    {
        UINT8_VEC_1D record_bytes = read_bytes(data, record_size);  // ← CALLS decoding_utils.cpp

        index_records.push_back(std::unordered_map<std::string, u_int64_t>({
            {"date_time",     read_n_bits(record_bytes,   0, 64)},  // ← CALLS decoding_utils.cpp
            {"time_delta",    read_n_bits(record_bytes,  64, 64)},
            {"data_size",     read_n_bits(record_bytes, 128, 32)},
            {"unit_offset",   read_n_bits(record_bytes, 160, 32)},
            {"byte_offset",   read_n_bits(record_bytes, 192, 64)},
            {"variable_flag", read_n_bits(record_bytes, 256,  8)},
            {"spare_data",    read_n_bits(record_bytes, 264, 24)}
        }));
    }
    return index_records;
}
```
- **Called when processing auxiliary files**: Reads index information
- **Fixed record size**: 36-byte records with structured fields
- **Bit field extraction**: Precise extraction of multi-bit fields

---

## Complete System Execution Flow

### Summary of Sequential File Usage

**Step 46: Complete Call Chain for Image Processing**

1. **User runs executable** → `image_write_main.cpp` starts
2. **Command parsing** → `cli.cpp` validates and processes arguments
3. **Command dispatch** → `image_write.cpp` handles specific image operations
4. **High-level processing** → `s1_decoder.cpp` orchestrates data processing
5. **Packet management** → `packet.cpp` handles individual packet decoding
6. **Low-level decoding** → `decoding_utils.cpp` performs binary data extraction
7. **Constants and structures** → `structs.h` provides lookup tables and definitions
8. **Signal processing** → `signal_processing.cpp` performs FFTs and data manipulation
9. **Image formation** → `image_formation.cpp` implements SAR focusing algorithms
10. **Doppler processing** → `doppler.cpp` handles Doppler analysis for TOPS mode
11. **State vectors** → `state_vectors.cpp` manages satellite ephemeris
12. **Type definitions** → `misc_types.h` ensures consistent data types

**Step 47: Processing Mode Dependencies**

**Raw Data Output:**
- `image_write_main.cpp` → `cli.cpp` → `image_write.cpp` → `s1_decoder.cpp` → `packet.cpp` → `decoding_utils.cpp`

**Range-Compressed Output:**
- Add: `signal_processing.cpp` → `image_formation.cpp`

**Azimuth-Compressed Output (Full SAR Processing):**
- Add: `doppler.cpp` → `state_vectors.cpp` + advanced SAR algorithms

**Step 48: Data Flow Through System**

```
Raw SAR File → Command Line Interface → Command Validation
                                           ↓
S1_Decoder Creation → Packet Reading → Header Parsing → Payload Decoding
                                                            ↓
                    ← Signal Processing ← Bit Extraction ← FDBAQ/Huffman Decoding
                            ↓
Range Compression (optional) → Azimuth Compression (optional) → Output Scaling
                                      ↓                              ↓
              Doppler Analysis → State Vector Interpolation → Image File Writing
```

**Step 49: Key Architectural Features**

- **Modular Design**: Each file handles specific functionality
- **Template-based**: Heavy use of C++ templates and STL containers
- **Parallel Processing**: OpenMP integration for multi-threaded operations
- **Memory Efficiency**: In-place operations and smart memory management
- **Error Handling**: Comprehensive exception handling throughout
- **Extensible**: Clean interfaces allow easy addition of new processing modes

**Step 50: Performance Optimizations**

- **FFTW Integration**: Optimized FFT library for signal processing
- **Parallel Packet Processing**: Multi-threaded packet decoding
- **Lazy Evaluation**: Signals only decoded when needed
- **Memory Management**: Raw data freed after processing
- **Template Specialization**: Compile-time optimization for different data types

This C++ implementation provides a complete, high-performance SAR processing system that can handle the full range of Sentinel-1 data products, from raw I/Q samples through fully focused SAR images, with support for all major Sentinel-1 acquisition modes including TOPS, Stripmap, and Wave modes.